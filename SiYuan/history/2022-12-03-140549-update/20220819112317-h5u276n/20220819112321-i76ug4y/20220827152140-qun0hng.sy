{
	"ID": "20220827152140-qun0hng",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20220827152140-qun0hng",
		"scroll": "{\u0026amp;quot;startId\u0026amp;quot;:\u0026amp;quot;20220827152215-c4jgmte\u0026amp;quot;,\u0026amp;quot;endId\u0026amp;quot;:\u0026amp;quot;20220827152215-ck23lr8\u0026amp;quot;,\u0026amp;quot;scrollTop\u0026amp;quot;:3127,\u0026amp;quot;focusId\u0026amp;quot;:\u0026amp;quot;20220827152215-54s0coh\u0026amp;quot;,\u0026amp;quot;focusStart\u0026amp;quot;:32,\u0026amp;quot;focusEnd\u0026amp;quot;:32}",
		"title": "Redis 内存优化",
		"updated": "20220924155327"
	},
	"Children": [
		{
			"ID": "20220827152215-c4jgmte",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-c4jgmte",
				"updated": "20220827152254"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们应该从 Redis 是如何保存数据的原理展开，分析键值对的存储结构和原理。"
				}
			]
		},
		{
			"ID": "20220827152215-tqtb8a1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-tqtb8a1",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "从而继续延展出每种数据类型底层的数据结构，针对不同场景使用更恰当的数据结构和编码实现更少的内存占用。"
				}
			]
		},
		{
			"ID": "20220827152215-k5rkec9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-k5rkec9",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "为了保存数据， Redis 需要先申请内存，数据过期或者内存淘汰需要回收内存，从而拓展出内存碎片优化。"
				}
			]
		},
		{
			"ID": "20220827152215-7lccnip",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-7lccnip",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "最后，说下 key、value 使用规范和技巧、 Bitmap 等高阶数据类型，运用这些技巧巧妙解决有限内存去存储更多数据难题……"
				}
			]
		},
		{
			"ID": "20220827152215-z0xzrnc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-z0xzrnc",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这一套组合拳下来直接封神。"
				}
			]
		},
		{
			"ID": "20220827152215-l490wp0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-l490wp0",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "主要优化神技如下："
				}
			]
		},
		{
			"ID": "20220827152215-k0q0vae",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220827152215-k0q0vae",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"ID": "20220827152215-r5qpft3",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-r5qpft3",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-58tym7w",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-58tym7w",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "键值对优化；"
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-ede2qud",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-ede2qud",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-wq5trxj",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-wq5trxj",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "小数据集合的编码优化；"
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-jo62a6k",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-jo62a6k",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-u6v7zxi",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-u6v7zxi",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "使用对象共享池；"
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-ergh5zh",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-ergh5zh",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-o8xfk3n",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-o8xfk3n",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "使用 Bit 比特位或 byte 级别操作"
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-b12ds85",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-b12ds85",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-u9mcmnd",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-u9mcmnd",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "使用 hash 类型优化；"
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-ly21q2j",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-ly21q2j",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-46lzdh6",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-46lzdh6",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "内存碎片优化；"
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-ll42d2d",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-ll42d2d",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-8w170rd",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-8w170rd",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "使用 32 位的 Redis。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-m3h8m4z",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-m3h8m4z",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在优化之前，我们先掌握 Redis 是如何存储数据的。"
				}
			]
		},
		{
			"ID": "20220827152215-ying5tg",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20220827152215-ying5tg",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Redis 如何存储键值对"
				}
			]
		},
		{
			"ID": "20220827152215-6ii33w0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-6ii33w0",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Redis 以 "
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "redisDb"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "为中心存储，redis 7.0 源码在 "
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "https://github.com/redis/redis/blob/7.0/src/server.h"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "："
				}
			]
		},
		{
			"ID": "20220827152215-h3o538o",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-h3o538o",
				"updated": "20220827152331"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20220827152331-wzg64fh.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​\nredisDb"
				}
			]
		},
		{
			"ID": "20220827152215-jhf5828",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220827152215-jhf5828",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"ID": "20220827152215-rt39ubp",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-rt39ubp",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-23xwuqt",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-23xwuqt",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "dict："
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " 最重要的属性之一，就是靠这个定义了保存了对象数据键值对，dcit 的底层结构是一个哈希表。"
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-b1bomlj",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-b1bomlj",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-f7igaig",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-f7igaig",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "expires："
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " 保存着所有 key 的过期信息."
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-lttatdx",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-lttatdx",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-te2vvro",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-te2vvro",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "blocking_keys 和 ready_keys 主要为了"
								},
								{
									"Type": "NodeEmphasis",
									"Data": "em",
									"Children": [
										{
											"Type": "NodeEmA6kOpenMarker",
											"Data": "*"
										},
										{
											"Type": "NodeText",
											"Data": "实现 BLPOP 等阻塞命令"
										},
										{
											"Type": "NodeEmA6kCloseMarker",
											"Data": "*"
										}
									]
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-xmsegfa",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-xmsegfa",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-9zu8bqz",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-9zu8bqz",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "watched_keys用于实现watch命令， "
								},
								{
									"Type": "NodeEmphasis",
									"Data": "em",
									"Children": [
										{
											"Type": "NodeEmA6kOpenMarker",
											"Data": "*"
										},
										{
											"Type": "NodeText",
											"Data": "记录正在被watch的一些key"
										},
										{
											"Type": "NodeEmA6kCloseMarker",
											"Data": "*"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ，与事务相关。"
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-y0muakz",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-y0muakz",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-ko42i0x",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-ko42i0x",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "id 为 "
								},
								{
									"Type": "NodeEmphasis",
									"Data": "em",
									"Children": [
										{
											"Type": "NodeEmA6kOpenMarker",
											"Data": "*"
										},
										{
											"Type": "NodeText",
											"Data": "当前数据库的id"
										},
										{
											"Type": "NodeEmA6kCloseMarker",
											"Data": "*"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ，redis 支持单个服务多数据库，默认有16个；"
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-g0qdkr5",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-g0qdkr5",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-bzvjtsd",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-bzvjtsd",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "clusterSlotToKeyMapping：cluster 模式下，存储key 与哈希槽映射关系的数组。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-ygztgie",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-ygztgie",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Redis 使用「dict」结构来保存所有的键值对（key-value）数据，这是一个全局哈希表，所以对 key 的查询能以 O(1) 时间得到。"
				}
			]
		},
		{
			"ID": "20220827152215-2eavybe",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-2eavybe",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "所谓哈希表，我们可以类比 Java 中的 "
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "HashMap"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，其实就是一个数组，数组的每个元素叫做哈希桶。"
				}
			]
		},
		{
			"ID": "20220827152215-t9aos3s",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-t9aos3s",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "dict 结构如下，源码在 "
						},
						{
							"Type": "NodeCodeSpan",
							"Data": "code",
							"Children": [
								{
									"Type": "NodeCodeSpanOpenMarker"
								},
								{
									"Type": "NodeCodeSpanContent",
									"Data": "https://github.com/redis/redis/blob/7.0/src/dict.h"
								},
								{
									"Type": "NodeCodeSpanCloseMarker"
								}
							]
						},
						{
							"Type": "NodeText",
							"Data": "："
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-kvi6e9t",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220827152215-kvi6e9t",
				"updated": "20220924155321"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Yw=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "struct dict {\n    // 特定类型的处理函数\n    dictType *type;\n    // 两个全局哈希表指针数组，与渐进式 rehash 有关\n    dictEntry **ht_table[2];\n    // 记录 dict 中现有的数据个数。\n    unsigned long ht_used[2];\n   // 记录渐进式 rehash 进度的标志， -1 表示当前没有执行 rehash \n    long rehashidx;\n\n   // 小于 0 表示 rehash 暂停\n    int16_t pauserehash;\n    signed char ht_size_exp[2];\n};\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220827152215-4atdi9d",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220827152215-4atdi9d",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"ID": "20220827152215-x2zpc1n",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-x2zpc1n",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-sqgrk74",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-sqgrk74",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "dictType：存储了hash函数，key和value的复制等函数；"
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-8b8uo5a",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-8b8uo5a",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-wq9878a",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-wq9878a",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "ht_table：长度为 2 的 数组，正常情况使用 ht_table[0] 存储数据，当执行 rehash 的时候，使用 ht_table[1]  配合完成 。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-je96naj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-je96naj",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "key 的哈希值最终会映射到 ht_table  的一个位置，如果发生哈希冲突，则拉出一个哈希链表。"
				}
			]
		},
		{
			"ID": "20220827152215-22h4jho",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-22h4jho",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "大家重点关注 "
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "dictEntry"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 类型的 ht_table，ht_table 数组每个位置我们也叫做 "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "哈希桶"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " ，就是这玩意保存了所有键值对。"
				}
			]
		},
		{
			"ID": "20220827152215-3fcbzh9",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20220827152215-3fcbzh9",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20220827152215-19v4iv0",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20220827152215-19v4iv0",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "❝码哥，Redis 支持那么多的数据类型，哈希桶咋保存？"
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-plhgwq4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-plhgwq4",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "哈希桶的每个元素的结构由 dictEntry 定义："
				}
			]
		},
		{
			"ID": "20220827152215-w1f9odm",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220827152215-w1f9odm",
				"updated": "20220924155316"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Yw=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "typedef struct dictEntry {\n   // 指向 key 的指针\n    void *key;\n    union {\n        // 指向实际 value 的指针\n        void *val;\n        uint64_t u64;\n        int64_t s64;\n        double d;\n    } v;\n    // 哈希冲突拉出的链表\n    struct dictEntry *next;\n} dictEntry;\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220827152215-tofz78f",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220827152215-tofz78f",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"ID": "20220827152215-byknkpd",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-byknkpd",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-f62wzom",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-f62wzom",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "key 指向键值对的键的指针，key 都是 string 类型。"
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-fhk0568",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-fhk0568",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-u5vtjl2",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-u5vtjl2",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeEmphasis",
									"Data": "em",
									"Children": [
										{
											"Type": "NodeEmA6kOpenMarker",
											"Data": "*"
										},
										{
											"Type": "NodeText",
											"Data": "value"
										},
										{
											"Type": "NodeEmA6kCloseMarker",
											"Data": "*"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " 是个 union（联合体）当它的值是 uint64_t、int64_t 或 double 类型时，就不再需要额外的存储，这有利于减少内存碎片。（为了节省内存操碎了心）当然，"
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "val 也可以是 void 指针，指向值的指针，以便能存储任何类型的数据。"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-xtwslgd",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-xtwslgd",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-oi41xzd",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-oi41xzd",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeEmphasis",
									"Data": "em",
									"Children": [
										{
											"Type": "NodeEmA6kOpenMarker",
											"Data": "*"
										},
										{
											"Type": "NodeText",
											"Data": "next"
										},
										{
											"Type": "NodeEmA6kCloseMarker",
											"Data": "*"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "  指向另一个 dictEntry 结构， 多个 dictEntry 可以通过 next 指针串连成链表， 从这里可以看出， ht_table 使用链地址法来处理键碰撞："
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "当多个不同的键拥有相同的哈希值时，哈希表用一个链表将这些键连接起来。"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-9acgvjk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-9acgvjk",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "哈希桶并没有保存值本身，而是指向具体值的指针，从而实现了哈希桶能存不同数据类型的需求"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 。"
				}
			]
		},
		{
			"ID": "20220827152215-wvszdy8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-wvszdy8",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "而哈希桶中，键值对的值都是由一个叫做 "
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "redisObject"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 的对象定义，源码地址："
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "https://github.com/redis/redis/blob/7.0/src/server.h"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20220827152215-h21efnr",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220827152215-h21efnr",
				"updated": "20220924155327"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Yw=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "typedef struct redisObject {\n    unsigned type:4;\n    unsigned encoding:4;\n    unsigned lru:LRU_BITS;\n    int refcount;\n    void *ptr;\n} robj;\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220827152215-pzyf9gm",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220827152215-pzyf9gm",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"ID": "20220827152215-qk7ulmb",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-qk7ulmb",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-y048o26",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-y048o26",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "type"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ：记录了对象的类型，string、set、hash 、Lis、Sorted Set 等，根据该类型才可以确定是哪种数据类型，使用什么样的 API 操作。"
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-45j3p8i",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-45j3p8i",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-vm0zw1l",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-vm0zw1l",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "encoding"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ：编码方式，"
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "表示 ptr 指向的数据类型具体数据结构，即这个对象使用了什么数据结构作为底层实现"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "保存数据。"
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "同一个对象使用不同编码实现内存占用存在明显差异，内部编码对内存优化非常重要。"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-wa0elml",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-wa0elml",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-iagrq4b",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-iagrq4b",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "lru:LRU_BITS：LRU 策略下对象最后一次被访问的时间，如果是 LFU 策略，那么低 8 位表示访问频率，高 16 位表示访问时间。"
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-friwu6r",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-friwu6r",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-bbp3ssv",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-bbp3ssv",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "refcount ：表示引用计数，由于 C 语言并不具备内存回收功能，所以 Redis 在自己的对象系统中添加了这个属性，当一个对象的引用计数为 0 时，则表示该对象已经不被任何对象引用，则可以进行垃圾回收了。"
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-tapy32h",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-tapy32h",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-8ekncdy",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-8ekncdy",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "ptr 指针：指向对象的底层实现数据结构，指向 "
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "值的指针"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " 。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-qj4ntve",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-qj4ntve",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如下图是由 redisDb、dict、dictEntry、redisObejct 关系图："
				}
			]
		},
		{
			"ID": "20220827152215-j21f7y0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-j21f7y0",
				"updated": "20220827152344"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20220827152344-udqn3tj.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​\nredis存储结构"
				}
			]
		},
		{
			"ID": "20220827152215-fnyd6wx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-fnyd6wx",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "「码哥」再唠叨几句，void *key  和 void *value 指针指向的是  "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "redisObject"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " ，Redis 中每个对象都是用 "
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "redisObject"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 表示。"
				}
			]
		},
		{
			"ID": "20220827152215-v7dhtiy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-v7dhtiy",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "知道了 Redis 存储原理以及不同数据类型的存储数据结构后，我们继续看如何做性能优化。"
				}
			]
		},
		{
			"ID": "20220827152215-df0nw0i",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20220827152215-df0nw0i",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1. 键值对优化"
				}
			]
		},
		{
			"ID": "20220827152215-pjyz6im",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-pjyz6im",
				"updated": "20220829171030"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "当我们执行 "
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "set key value"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 的命令，"
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "*key"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "指针指向 SDS 字符串保存 key，而 "
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "value"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "的值保存在 "
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "*ptr"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 指针指向的数据结构，消耗的内存：key + value。"
				}
			]
		},
		{
			"ID": "20220827152215-bvlbkzt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-bvlbkzt",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "第一个优化神技："
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "降低 Redis 内存使用的最粗暴的方式就是缩减键（key）与值（value）的长度。"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-u28vw5y",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-u28vw5y",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在《"
				},
				{
					"Type": "NodeLink",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "Redis 很强，不懂使用规范就糟蹋了"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://mp.weixin.qq.com/s?__biz=MzkzMDI1NjcyOQ==\u0026mid=2247493190\u0026idx=1\u0026sn=a3b6e1b36eb676c0055babbf9864fece\u0026scene=21#wechat_redirect"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "》中我说过关于键值对的使用规范，对于 key 的命名使用「业务模块名:表名:数据唯一id」这样的方式方便定位问题。"
				}
			]
		},
		{
			"ID": "20220827152215-ymr9gwd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-ymr9gwd",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "比如：users:firends:996 表示用户系统中，id = 996 的朋友信息。我们可以简写为："
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "u:fs:996"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-fojt7dh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-fojt7dh",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "对于 key 的优化：使用单词简写方式优化内存占用。"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-cyvvsgw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-cyvvsgw",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "对于 value 的优化那就更多了："
				}
			]
		},
		{
			"ID": "20220827152215-sjsws27",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220827152215-sjsws27",
				"updated": "20220827152348"
			},
			"Children": [
				{
					"ID": "20220827152215-1ro9hrr",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-1ro9hrr",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-chg1qb8",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-chg1qb8",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "过滤不必要的数据"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ：不要大而全的一股脑将所有信息保存，想办法去掉一些不必要的属性，比如缓存登录用户的信息，通常只需要存储昵称、性别、账号等。"
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-ryzsd9f",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-ryzsd9f",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-jql8k4n",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-jql8k4n",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "精简数据"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ：比如用户的会员类型：0 表示「屌丝」、1 表示 「VIP」、2表示「VVIP」。而不是存储 VIP 这个字符串。"
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-qm00txn",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-qm00txn",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-omm6c34",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-omm6c34",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "数据压缩："
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " 对数据的内容进行压缩，比如使用 GZIP、Snappy。"
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-g1irc3f",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-g1irc3f",
						"updated": "20220827152348"
					},
					"Children": [
						{
							"ID": "20220827152215-y5kn3a1",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-y5kn3a1",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "使用性能好，内存占用小的序列化方式"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " 。比如 Java 内置的序列化不管是速度还是压缩比都不行，我们可以选择 protostuff，kryo等方式。如下图 Java 常见的序列化工具空间压缩比："
								}
							]
						},
						{
							"ID": "20220827152215-0eud1pf",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-0eud1pf",
								"updated": "20220827152348"
							},
							"Children": [
								{
									"Type": "NodeImage",
									"Data": "span",
									"Children": [
										{
											"Type": "NodeBang"
										},
										{
											"Type": "NodeOpenBracket"
										},
										{
											"Type": "NodeLinkText",
											"Data": "image"
										},
										{
											"Type": "NodeCloseBracket"
										},
										{
											"Type": "NodeOpenParen"
										},
										{
											"Type": "NodeLinkDest",
											"Data": "assets/image-20220827152348-a7sb6a8.png"
										},
										{
											"Type": "NodeCloseParen"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "​\n序列化工具压缩比"
								}
							]
						},
						{
							"ID": "20220827152215-kjs9dr9",
							"Type": "NodeBlockquote",
							"Properties": {
								"id": "20220827152215-kjs9dr9",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeBlockquoteMarker",
									"Data": "\u003e"
								},
								{
									"ID": "20220827152215-eygcqnt",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20220827152215-eygcqnt",
										"updated": "20220827152215"
									},
									"Children": [
										{
											"Type": "NodeText",
											"Data": "❝靓仔们，我们通常使用 json 作为字符串存储在 Redis，用 json 存储与二进制数据存储有什么优缺点呢？"
										}
									]
								}
							]
						},
						{
							"ID": "20220827152215-ds9ewh2",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-ds9ewh2",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "json 格式的优点：方便调试和跨语言；缺点是：同样的数据相比字节数组占用的空间更大。"
								}
							]
						},
						{
							"ID": "20220827152215-pd06z5w",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-pd06z5w",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "一定要 json 格式的话，那就先通过压缩算法压缩 json，再把压缩后的数据存入 Redis。比如 GZIP 压缩后的 json 可降低约 60% 的空间。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-wu5buu3",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20220827152215-wu5buu3",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2. 小数据集合编码优化"
				}
			]
		},
		{
			"ID": "20220827152215-cn0lj62",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-cn0lj62",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "key 对象都是 string 类型，value 对象主要有五种基本数据类型："
				},
				{
					"Type": "NodeLink",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "String、List、Set、Zset、Hash"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://mp.weixin.qq.com/s?__biz=MzkzMDI1NjcyOQ==\u0026mid=2247487752\u0026idx=1\u0026sn=72a1725e1c86bb5e883dd8444e5bd6c4\u0026scene=21#wechat_redirect"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20220827152215-8pzpjvy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-8pzpjvy",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "数据类型与底层数据结构的关系如下所示："
				}
			]
		},
		{
			"ID": "20220827152215-d5jtl3m",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-d5jtl3m",
				"updated": "20220829172702"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/1_46XLDI_@@HLPG7G38-20220826132234-ypfdshl.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20220827152215-zg6lqse",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-zg6lqse",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "特别说明下在最新版（非稳定版本，时间 2022-7-3），"
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "ziplist 压缩列表由 "
						},
						{
							"Type": "NodeCodeSpan",
							"Data": "code",
							"Children": [
								{
									"Type": "NodeCodeSpanOpenMarker"
								},
								{
									"Type": "NodeCodeSpanContent",
									"Data": "quicklist"
								},
								{
									"Type": "NodeCodeSpanCloseMarker"
								}
							]
						},
						{
							"Type": "NodeText",
							"Data": " 代替（3.2 版本引入），而双向链表由 listpack 代替。"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-c7xyab2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-c7xyab2",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "另外，同一数据类型会根据键的数量和值的大小也有不同的底层编码类型实现。"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-ho2xwjp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-ho2xwjp",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在 Redis 2.2 版本之后，存储集合数据（Hash、List、Set、SortedSet）在满足某些情况下会采用内存压缩技术来实现使用更少的内存存储更多的数据。"
				}
			]
		},
		{
			"ID": "20220827152215-sddki4x",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-sddki4x",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "当这些集合中的数据元素数量小于某个值且元素的值占用的字节大小小于某个值的时候，存储的数据会用非常节省内存的方式进行编码，理论上至少节省 10 倍以上内存（平均节省 5 倍以上）。"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-y4w1hc8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-y4w1hc8",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "比如 Hash 类型里面的数据不是很多，虽然哈希表的时间复杂度是 O(1)，ziplist 的时间复杂度是 O(n)，但是使用 ziplist 保存数据的话会节省了内存，并且在少量数据情况下效率并不会降低很多。"
				}
			]
		},
		{
			"ID": "20220827152215-vj6u9sh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-vj6u9sh",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "所以我们需要尽可能地控制集合元素数量和每个元素的内存大小，这样能充分利用紧凑型编码减少内存占用。"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-pch9pn9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-pch9pn9",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "并且，这些编码对用户和 api 是无感知的，当集合数据超过配置文件的配置的最大值， Redis 会自动转成正常编码。"
				}
			]
		},
		{
			"ID": "20220827152215-9q1tsmb",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20220827152215-9q1tsmb",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20220827152215-4s2zsk0",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20220827152215-4s2zsk0",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "❝数据类型对应的编码规则如下所示"
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-d7r8j7k",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20220827152215-d7r8j7k",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "String 字符串"
				}
			]
		},
		{
			"ID": "20220827152215-tewm4kh",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220827152215-tewm4kh",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"ID": "20220827152215-hncmqrh",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-hncmqrh",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-2svrxvn",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-2svrxvn",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "int：整数且数字长度小于 20，直接保存在 *ptr 中。"
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-y821gia",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-y821gia",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-9mum8qn",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-9mum8qn",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "embstr：开辟一块连续分配的内存（字符串长度小于等于 44 字节）。"
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-woshxt1",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-woshxt1",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-rweb73p",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-rweb73p",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "raw：动态字符串（大于 44 字节的字符串，同时字符串小于 512 MB）。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-tol0v1x",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20220827152215-tol0v1x",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "List 列表"
				}
			]
		},
		{
			"ID": "20220827152215-fk270pu",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220827152215-fk270pu",
				"updated": "20220827152402"
			},
			"Children": [
				{
					"ID": "20220827152215-1tq5th7",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-1tq5th7",
						"updated": "20220827152402"
					},
					"Children": [
						{
							"ID": "20220827152215-vt0td6o",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-vt0td6o",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "ziplist：元素个数小于"
								},
								{
									"Type": "NodeCodeSpan",
									"Data": "code",
									"Children": [
										{
											"Type": "NodeCodeSpanOpenMarker"
										},
										{
											"Type": "NodeCodeSpanContent",
											"Data": "hash-max-ziplist-entries"
										},
										{
											"Type": "NodeCodeSpanCloseMarker"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "配置，同时所有的元素的值大小都小于 "
								},
								{
									"Type": "NodeCodeSpan",
									"Data": "code",
									"Children": [
										{
											"Type": "NodeCodeSpanOpenMarker"
										},
										{
											"Type": "NodeCodeSpanContent",
											"Data": "hash-max-ziplist-value"
										},
										{
											"Type": "NodeCodeSpanCloseMarker"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "配置。"
								}
							]
						},
						{
							"ID": "20220827152215-bxeyetd",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-bxeyetd",
								"updated": "20220827152402"
							},
							"Children": [
								{
									"Type": "NodeImage",
									"Data": "span",
									"Children": [
										{
											"Type": "NodeBang"
										},
										{
											"Type": "NodeOpenBracket"
										},
										{
											"Type": "NodeLinkText",
											"Data": "image"
										},
										{
											"Type": "NodeCloseBracket"
										},
										{
											"Type": "NodeOpenParen"
										},
										{
											"Type": "NodeLinkDest",
											"Data": "assets/image-20220827152402-nm5n18y.png"
										},
										{
											"Type": "NodeCloseParen"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "​\nziplist"
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-s96b4cs",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-s96b4cs",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-djd1z3y",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-djd1z3y",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "linkedlist：3.0 版本之前当列表类型无法满足 ziplist 的条件时，Redis会使用 linkedlist 作为列表的内部实现。"
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-7vfye1k",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-7vfye1k",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-kif3fjj",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-kif3fjj",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "quicklist：Redis  3.2 引入，并作为 List 数据类型的底层实现，不再使用双端链表 linkedlist 和 ziplist 实现。"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-xtqe8u8",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20220827152215-xtqe8u8",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Set 集合"
				}
			]
		},
		{
			"ID": "20220827152215-i7y5qqx",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220827152215-i7y5qqx",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"ID": "20220827152215-kljmj9f",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-kljmj9f",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-r533kra",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-r533kra",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "intset 整数集合：元素都是整数，且元素个数小于 "
								},
								{
									"Type": "NodeCodeSpan",
									"Data": "code",
									"Children": [
										{
											"Type": "NodeCodeSpanOpenMarker"
										},
										{
											"Type": "NodeCodeSpanContent",
											"Data": "set-max-intset-entries"
										},
										{
											"Type": "NodeCodeSpanCloseMarker"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "配置"
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-ausyfnz",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-ausyfnz",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-re3hjsj",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-re3hjsj",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "hashtable 哈希表：集合类型无法满足intset的条件时就会使用hashtable 编码。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-4cldvtp",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20220827152215-4cldvtp",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Hash 哈希表"
				}
			]
		},
		{
			"ID": "20220827152215-fhkrhqw",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220827152215-fhkrhqw",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"ID": "20220827152215-osdizc4",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-osdizc4",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-54s0coh",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-54s0coh",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "ziplist：元素个数小于 "
								},
								{
									"Type": "NodeCodeSpan",
									"Data": "code",
									"Children": [
										{
											"Type": "NodeCodeSpanOpenMarker"
										},
										{
											"Type": "NodeCodeSpanContent",
											"Data": "hash-max-ziplist-entries"
										},
										{
											"Type": "NodeCodeSpanCloseMarker"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "配置，同时任意一个 value 的占用字节大小都小于"
								},
								{
									"Type": "NodeCodeSpan",
									"Data": "code",
									"Children": [
										{
											"Type": "NodeCodeSpanOpenMarker"
										},
										{
											"Type": "NodeCodeSpanContent",
											"Data": "hash-max-ziplist-value"
										},
										{
											"Type": "NodeCodeSpanCloseMarker"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " 。"
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-lcg8o94",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-lcg8o94",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-8kuursg",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-8kuursg",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "hashtable：hash 类型无法满足 intset 的条件时就会使用hashtable。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-3ywlqdc",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20220827152215-3ywlqdc",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Sorted Set 有序集合"
				}
			]
		},
		{
			"ID": "20220827152215-j0ygh3u",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220827152215-j0ygh3u",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"ID": "20220827152215-2vpupqh",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-2vpupqh",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-31e90bc",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-31e90bc",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "ziplist：元素个数小于 "
								},
								{
									"Type": "NodeCodeSpan",
									"Data": "code",
									"Children": [
										{
											"Type": "NodeCodeSpanOpenMarker"
										},
										{
											"Type": "NodeCodeSpanContent",
											"Data": "zset-max-ziplist-entries"
										},
										{
											"Type": "NodeCodeSpanCloseMarker"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " 同时每个元素的value小于``zset-max-ziplist-value`配置。"
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-nevbjqn",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-nevbjqn",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-95txkqt",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-95txkqt",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "skiplist：当ziplist条件不满足时，有序集合会使用skiplist作为内部实现。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-701u52z",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-701u52z",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "以下是 Redis redis.conf  配置文件默认编码阈值配置："
				}
			]
		},
		{
			"ID": "20220827152215-y7qa1sx",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220827152215-y7qa1sx",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "hash-max-ziplist-entries 512\nhash-max-ziplist-value 64\nzset-max-ziplist-entries 128\nzset-max-ziplist-value 64\nset-max-intset-entries 512\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220827152215-0m8dn7l",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-0m8dn7l",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "下图是 "
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "reidsObject\u003cspan\u003e \u003c/span\u003e"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "对象的 type 和 encoding 对应关系图："
				}
			]
		},
		{
			"ID": "20220827152215-ik4tejq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-ik4tejq",
				"updated": "20220827152408"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20220827152408-1gufxfp.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​\ntype 与编码"
				}
			]
		},
		{
			"ID": "20220827152215-im693zn",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20220827152215-im693zn",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20220827152215-pqn7nfd",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20220827152215-pqn7nfd",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "❝码哥，为啥对一种数据类型实现多种不同编码方式？"
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-tkh34eo",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-tkh34eo",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "主要原因是想通过不同编码实现效率和空间的平衡。"
				}
			]
		},
		{
			"ID": "20220827152215-oda092e",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-oda092e",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "比如当我们的存储只有100个元素的列表，当使用双向链表数据结构时，需要维护大量的内部字段。"
				}
			]
		},
		{
			"ID": "20220827152215-bq5xtuj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-bq5xtuj",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "比如每个元素需要：前置指针，后置指针，数据指针等，造成空间浪费。"
				}
			]
		},
		{
			"ID": "20220827152215-olsbq65",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-olsbq65",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果采用连续内存结构的压缩列表(ziplist)，将会节省大量内存，而由于数据长度较小，存取操作时间复杂度即使为O(n) 性能也相差不大，因为 n 值小 与 O(1) 并明显差别。"
				}
			]
		},
		{
			"ID": "20220827152215-8brzydh",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220827152215-8brzydh",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "数据编码优化技巧"
				}
			]
		},
		{
			"ID": "20220827152215-dhq1q40",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-dhq1q40",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "ziplist 存储 list 时每个元素会作为一个 entry，存储 hash 时 key 和 value 会作为相邻的两个 entry。"
				}
			]
		},
		{
			"ID": "20220827152215-2dg13m2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-2dg13m2",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "存储 zset 时 member 和 score 会作为相邻的两个entry，当不满足上述条件时，ziplist 会升级为 linkedlist, hashtable 或 skiplist 编码。"
				}
			]
		},
		{
			"ID": "20220827152215-7u6g4fp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-7u6g4fp",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "由于目前大部分Redis运行的版本都是在3.2以上，所以 List 类型的编码都是quicklist"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 。"
				}
			]
		},
		{
			"ID": "20220827152215-u0quy22",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-u0quy22",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "quicklist 是 ziplist 和 linkedlist 的混合体，它将 linkedlist 按段切分，每一段使用 ziplist 来紧凑存储，多个 ziplist 之间使用双向指针串接起来。"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-cepwnnr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-cepwnnr",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "考虑了综合平衡空间碎片和读写性能两个维度所以使用了新编码 quicklist。"
				}
			]
		},
		{
			"ID": "20220827152215-jm6cw7z",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-jm6cw7z",
				"updated": "20220827152414"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20220827152414-5416rjs.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20220827152215-f39ka5e",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220827152215-f39ka5e",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "ziplist 的不足"
				}
			]
		},
		{
			"ID": "20220827152215-bfklqwi",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-bfklqwi",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "每次修改都可能触发 realloc 和 memcopy, 可能导致连锁更新(数据可能需要挪动)。"
				}
			]
		},
		{
			"ID": "20220827152215-ulke04c",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-ulke04c",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "因此修改操作的效率较低，在 ziplist 的元素很多时这个问题更加突出。"
				}
			]
		},
		{
			"ID": "20220827152215-lo1hai6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-lo1hai6",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "优化手段："
				}
			]
		},
		{
			"ID": "20220827152215-wu7q53z",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20220827152215-wu7q53z",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"ID": "20220827152215-k5qa5mf",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20220827152215-k5qa5mf",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-dp6cfx2",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-dp6cfx2",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "key 尽量控制在 44 字节以内，走 embstr 编码。"
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-5z704pk",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20220827152215-5z704pk",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-3e66a1e",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-3e66a1e",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "集合类型的 value 对象的元素个数不要太多太大，充分利用 ziplist 编码实现内存压缩。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-g3u4ry3",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20220827152215-g3u4ry3",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3. 对象共享池"
				}
			]
		},
		{
			"ID": "20220827152215-niruwob",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-niruwob",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "整数我们经常在工作中使用，Redis 在启动的时候默认生成一个  "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "0 ~9999 的整数对象共享池用于对象复用，减少内存占用"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 。"
				}
			]
		},
		{
			"ID": "20220827152215-r7iur8j",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-r7iur8j",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "比如执行"
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "set 码哥 18; set 吴彦祖 18;"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " key 等于 「码哥」 和「吴彦祖」的 value 都指向同一个对象。"
				}
			]
		},
		{
			"ID": "20220827152215-jampab9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-jampab9",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果 value 可以使用整数表示的话尽可能使用整数，这样即使大量键值对的 value 大量保存了 0~9999 范围内的整数，在实例中，其实只有一份数据。"
				}
			]
		},
		{
			"ID": "20220827152215-y1wnr5i",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-y1wnr5i",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "靓仔们，有两个大坑需要注意，它会导致对象共享池失效。"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-1j578oz",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220827152215-1j578oz",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"ID": "20220827152215-lqqboxa",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-lqqboxa",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-1sm2o2b",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-1sm2o2b",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "Redis 中设置了 maxmemory 限制最大内存占用大小且启用了 LRU 策略（allkeys-lru 或 volatile-lru 策略）。"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								}
							]
						},
						{
							"ID": "20220827152215-chjhlej",
							"Type": "NodeBlockquote",
							"Properties": {
								"id": "20220827152215-chjhlej",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeBlockquoteMarker",
									"Data": "\u003e"
								},
								{
									"ID": "20220827152215-4lhd5rt",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20220827152215-4lhd5rt",
										"updated": "20220827152215"
									},
									"Children": [
										{
											"Type": "NodeText",
											"Data": "❝码哥，为啥呀？"
										}
									]
								}
							]
						},
						{
							"ID": "20220827152215-9rr9182",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-9rr9182",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "因为 LRU 需要记录每个键值对的访问时间，都共享一个整数 对象，LRU 策略就无法进行统计了。"
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-q0j36rn",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-q0j36rn",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-feh1076",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-feh1076",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "集合类型的编码采用 ziplist 编码，并且集合内容是整数，也不能共享一个整数对象。"
								}
							]
						},
						{
							"ID": "20220827152215-rnsa3ey",
							"Type": "NodeBlockquote",
							"Properties": {
								"id": "20220827152215-rnsa3ey",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeBlockquoteMarker",
									"Data": "\u003e"
								},
								{
									"ID": "20220827152215-bh8m133",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20220827152215-bh8m133",
										"updated": "20220827152215"
									},
									"Children": [
										{
											"Type": "NodeText",
											"Data": "❝这又是为啥呢？"
										}
									]
								}
							]
						},
						{
							"ID": "20220827152215-inh4p0p",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-inh4p0p",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "使用了 ziplist 紧凑型内存结构存储数据，判断整数对象是否共享的效率很低。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-q5zk3w8",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20220827152215-q5zk3w8",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "4.使用 Bit 比特位或 byte 级别操作"
				}
			]
		},
		{
			"ID": "20220827152215-x0zysl4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-x0zysl4",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "比如在一些「二值状态统计」的场景下使用 Bitmap 实现，对于网页 UV 使用 HyperLogLog 来实现，大大减少内存占用。"
				}
			]
		},
		{
			"ID": "20220827152215-jt9hnq6",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20220827152215-jt9hnq6",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20220827152215-y8751qt",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20220827152215-y8751qt",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "❝码哥，什么是二值状态统计呀？"
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-5c0at87",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-5c0at87",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "也就是集合中的元素的值只有 0 和 1 两种，在签到打卡和用户是否登陆的场景中，只需记录"
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "签到(1)"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "或 "
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "未签到(0)"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，"
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "已登录(1)"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "或"
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "未登陆(0)"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20220827152215-u0xkxdz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-u0xkxdz",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "假如我们在判断用户是否登陆的场景中使用 Redis 的 String 类型实现（ "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "key -\u003e userId，value -\u003e 0 表示下线，1 - 登陆"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " ），假如存储 100 万个用户的登陆状态，如果以字符串的形式存储，就需要存储 100 万个字符串，内存开销太大。"
				}
			]
		},
		{
			"ID": "20220827152215-in51ij8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-in51ij8",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "String 类型除了记录实际数据以外，还需要额外的内存记录数据长度、空间使用等信息。"
				}
			]
		},
		{
			"ID": "20220827152215-3eakv5s",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-3eakv5s",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Bitmap 的底层数据结构用的是 String 类型的 SDS 数据结构来保存位数组，Redis 把每个字节数组的 8 个 bit 位利用起来，每个 bit 位 表示一个元素的二值状态（不是 0 就是 1）。"
				}
			]
		},
		{
			"ID": "20220827152215-9wiwet3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-9wiwet3",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "可以将 Bitmap 看成是一个 bit 为单位的数组，数组的每个单元只能存储 0 或者 1，数组的下标在 Bitmap 中叫做 offset 偏移量。"
				}
			]
		},
		{
			"ID": "20220827152215-t5pf9zo",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-t5pf9zo",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "为了直观展示，我们可以理解成 buf 数组的每个字节用一行表示，每一行有 8 个 bit 位，8 个格子分别表示这个字节中的 8 个 bit 位，如下图所示："
				}
			]
		},
		{
			"ID": "20220827152215-ao94qpo",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-ao94qpo",
				"updated": "20220827152418"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20220827152418-22lmxwi.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20220827152215-8we7r91",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-8we7r91",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "8 个 bit 组成一个 Byte，所以 Bitmap 会极大地节省存储空间。"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 这就是 Bitmap 的优势。"
				}
			]
		},
		{
			"ID": "20220827152215-kegxc71",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-kegxc71",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "关于 Bitmap 的详细解答，大家可移步 -\u003e "
				},
				{
					"Type": "NodeLink",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "《Redis 实战篇：巧用 Bitmap 实现亿级数据统计》"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://mp.weixin.qq.com/s?__biz=MzkzMDI1NjcyOQ==\u0026mid=2247487813\u0026idx=1\u0026sn=9b346ad34a3b8cf38a3f338e85804800\u0026scene=21#wechat_redirect"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20220827152215-dug2x5v",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20220827152215-dug2x5v",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "5. 妙用 Hash 类型优化"
				}
			]
		},
		{
			"ID": "20220827152215-ylwsdt4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-ylwsdt4",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "尽可能把数据抽象到一个哈希表里。"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-jg0gnly",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-jg0gnly",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "比如说系统中有一个用户对象，我们不需要为一个用户的昵称、姓名、邮箱、地址等单独设置一个 key，而是将这个信息存放在一个哈希表里。"
				}
			]
		},
		{
			"ID": "20220827152215-1y0pfce",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-1y0pfce",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如下所示："
				}
			]
		},
		{
			"ID": "20220827152215-wd3ag9c",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220827152215-wd3ag9c",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "hset users:深圳:999 姓名 码哥\nhset users:深圳:999 年龄 18\nhset users:深圳:999 爱好 女\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220827152215-2ram2d9",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20220827152215-2ram2d9",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20220827152215-ji7a6fl",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20220827152215-ji7a6fl",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "❝为啥使用 String 类型，为每个属性设置一个 key 会占用大量内存呢？"
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-ews8386",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-ews8386",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "因为 Redis 的数据类型有很多，不同数据类型都有些相同的元数据要记录（比如最后一次访问的时间、被引用的次数等）。"
				}
			]
		},
		{
			"ID": "20220827152215-8v8j94f",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-8v8j94f",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "所以，Redis 会用一个 RedisObject 结构体来统一记录这些元数据，用 *prt 指针指向实际数据。"
				}
			]
		},
		{
			"ID": "20220827152215-sum9tjh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-sum9tjh",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "当我们为每个属性都创建 key，就会创建大量的 "
						},
						{
							"Type": "NodeCodeSpan",
							"Data": "code",
							"Children": [
								{
									"Type": "NodeCodeSpanOpenMarker"
								},
								{
									"Type": "NodeCodeSpanContent",
									"Data": "redisObejct"
								},
								{
									"Type": "NodeCodeSpanCloseMarker"
								}
							]
						},
						{
							"Type": "NodeText",
							"Data": " 对象占用内存。"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-lo1pewy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-lo1pewy",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如下所示  redisObject 内存占用："
				}
			]
		},
		{
			"ID": "20220827152215-ud4zcwc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-ud4zcwc",
				"updated": "20220827152426"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20220827152426-fdil4ug.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​\nredisObejct"
				}
			]
		},
		{
			"ID": "20220827152215-98cfx2g",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-98cfx2g",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "用 Hash 类型的话，每个用户只需要设置一个 key。"
				}
			]
		},
		{
			"ID": "20220827152215-5xg8mov",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20220827152215-5xg8mov",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "6. 内存碎片优化"
				}
			]
		},
		{
			"ID": "20220827152215-tjckfg2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-tjckfg2",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Redis 释放的内存空间可能并不是连续的，这些不连续的内存空间很有可能处于一种闲置的状态。"
				}
			]
		},
		{
			"ID": "20220827152215-58ab3b1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-58ab3b1",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "虽然有空闲空间，Redis 却无法用来保存数据，不仅会减少 Redis 能够实际保存的数据量，还会降低 Redis 运行机器的成本回报率。"
				}
			]
		},
		{
			"ID": "20220827152215-zuu34m4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-zuu34m4",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "比如， Redis 存储一个整形数字集合需要一块占用 32 字节的连续内存空间，当前虽然有 64 字节的空闲，但是他们都是不连续的，导致无法保存。"
				}
			]
		},
		{
			"ID": "20220827152215-513g38d",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20220827152215-513g38d",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20220827152215-dioasn2",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20220827152215-dioasn2",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "❝内存碎片是如何形成呢？"
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-4u9xm0i",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-4u9xm0i",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "两个层面原因导致："
				}
			]
		},
		{
			"ID": "20220827152215-ak1qj9h",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220827152215-ak1qj9h",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"ID": "20220827152215-nuq1gi0",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-nuq1gi0",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-tgbt4bs",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-tgbt4bs",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "操作系统内存分配机制：内存分配策略决定了无法做到按需分配。因为分配器是按照固定大小来分配内存。"
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-ka1ojgt",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-ka1ojgt",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-y57u5xe",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-y57u5xe",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "键值对被修改和删除，从而导致内存空间的扩容和释放。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-dhyjcix",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-dhyjcix",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "碎片优化可以降低内存使用率，提高访问效率，在4.0以下版本，我们只能使用重启恢复：重启加载 RDB 或者通过高可用主从切换实现数据的重新加载减少碎片。"
				}
			]
		},
		{
			"ID": "20220827152215-r276zc0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-r276zc0",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在4.0以上版本，Redis提供了自动和手动的碎片整理功能，原理大致是把数据拷贝到新的内存空间，然后把老的空间释放掉，这个是有一定的性能损耗的。"
				}
			]
		},
		{
			"ID": "20220827152215-7ix1dhl",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-7ix1dhl",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "因为 Redis 是单线程，在数据拷贝时，Redis 只能等着，这就导致 Redis 无法处理请求，性能就会降低。"
				}
			]
		},
		{
			"ID": "20220827152215-zfph3td",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20220827152215-zfph3td",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "手动整理碎片"
				}
			]
		},
		{
			"ID": "20220827152215-q7oh1f6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-q7oh1f6",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "执行 "
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "memory purge"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "命令即可。"
				}
			]
		},
		{
			"ID": "20220827152215-bcbhjwu",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20220827152215-bcbhjwu",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "自动整理内存碎片"
				}
			]
		},
		{
			"ID": "20220827152215-96f1nm3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-96f1nm3",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "使用 "
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "config set activedefrag yes"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 指令或者在 redis.conf 配置 "
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "activedefrag yes"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 将 activedefrag 配置成 yes 表示启动自动清理功能。"
				}
			]
		},
		{
			"ID": "20220827152215-3j3pgnh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-3j3pgnh",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这个配置还不够，至于啥时候清理还需要看下面的两个配置："
				}
			]
		},
		{
			"ID": "20220827152215-e1vikn3",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220827152215-e1vikn3",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"ID": "20220827152215-yc3ymfs",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-yc3ymfs",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-4emk18f",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-4emk18f",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "active-defrag-ignore-bytes 200mb：内存碎片的大小达到 200MB，开始清理。"
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-jn0se1s",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-jn0se1s",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-skidvyj",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-skidvyj",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "active-defrag-threshold-lower 6：表示内存碎片空间占操作系统分配给 Redis 的总空间比例达到 6% 时，开始清理。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-uv8yxsz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-uv8yxsz",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "只有满足这两个条件， Redis 才会执行内存碎片自动清理。"
				}
			]
		},
		{
			"ID": "20220827152215-ctzvsde",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-ctzvsde",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "除此之外，Redis 为了防止清理碎片对 Redis 正常处理指令造成影响，有两个参数用于控制清理操作占用 CPU 的时间比例上下限。"
				}
			]
		},
		{
			"ID": "20220827152215-1olcgdm",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220827152215-1olcgdm",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"ID": "20220827152215-1dmfv0t",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-1dmfv0t",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-5wlpvze",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-5wlpvze",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "active-defrag-cycle-min 15：自动清理过程所用 CPU 时间的比例不低于 15%，保证清理能有效展开。"
								}
							]
						}
					]
				},
				{
					"ID": "20220827152215-m8s0dmg",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220827152215-m8s0dmg",
						"updated": "20220827152215"
					},
					"Children": [
						{
							"ID": "20220827152215-zxtb4vc",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220827152215-zxtb4vc",
								"updated": "20220827152215"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "active-defrag-cycle-max 50：表示自动清理过程所用 CPU 时间的比例不能大于 50%，一旦超过，就停止清理，从而避免在清理时，大量的内存拷贝阻塞 Redis执行命令。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220827152215-ot1rdeo",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20220827152215-ot1rdeo",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "7. 使用 32 位的 Redis"
				}
			]
		},
		{
			"ID": "20220827152215-al6y79l",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-al6y79l",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "使用32位的redis，对于每一个key,将使用更少的内存，因为32位程序，指针占用的字节数更少。"
				}
			]
		},
		{
			"ID": "20220827152215-due175o",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-due175o",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "但是32的Redis整个实例使用的内存将被限制在4G以下。我们可以通过 cluster 模式将多个小内存节点构成一个集群，从而保存更多的数据。"
				}
			]
		},
		{
			"ID": "20220827152215-p7uat7x",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-p7uat7x",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "另外小内存的节点 fork 生成 rdb 的速度也更快。"
				}
			]
		},
		{
			"ID": "20220827152215-ck23lr8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220827152215-ck23lr8",
				"updated": "20220827152215"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "RDB和AOF文件是不区分32位和64位的（包括字节顺序）,所以你可以使用64位的Redis 恢复32位的RDB备份文件，相反亦然。"
				}
			]
		}
	]
}