{
	"ID": "20230113084814-p9k93gn",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20230113084814-p9k93gn",
		"scroll": "{\u0026amp;quot;startId\u0026amp;quot;:\u0026amp;quot;20230113084815-i6hee44\u0026amp;quot;,\u0026amp;quot;endId\u0026amp;quot;:\u0026amp;quot;20230113105122-rvwuz4n\u0026amp;quot;,\u0026amp;quot;scrollTop\u0026amp;quot;:24497,\u0026amp;quot;focusId\u0026amp;quot;:\u0026amp;quot;20230113104944-9r743xw\u0026amp;quot;,\u0026amp;quot;focusStart\u0026amp;quot;:27,\u0026amp;quot;focusEnd\u0026amp;quot;:27}",
		"title": "正则表达式",
		"updated": "20230113105127"
	},
	"Children": [
		{
			"ID": "20230113084815-i6hee44",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230113084815-i6hee44",
				"updated": "20230113100732"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1、元字符的分类与记忆技巧"
				}
			]
		},
		{
			"ID": "20230113085220-qda9kuj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085220-qda9kuj",
				"updated": "20230113085226"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "正则表达式中有很多的“元字符”，比如刚刚提到的 \\d，它在正则中不代表 \\ （反斜杠） 加字母 d，而是代表任意数字，这种表示特殊含义的字符表示，就是元字符。正则表达式中，元字符非常多，那么我们如何才能记住它们呢？"
				}
			]
		},
		{
			"ID": "20230113085231-yfj3m6n",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085231-yfj3m6n",
				"updated": "20230113085232"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这里我给你介绍一个方法，就是分类记忆。元字符虽然非常多，但如果我们按照分类法去理解记忆，效果会好很多。事实上，这个方法不光可以用在记忆元字符上，也可以用在记忆各种看似没有章法的内容上。"
				}
			]
		},
		{
			"ID": "20230113085233-fvjs53c",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085233-fvjs53c",
				"updated": "20230113085239"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "首先，我可以把元字符大致分成这几类：表示单个特殊字符的，表示空白符的，表示某个范围的，表示次数的量词，另外还有表示断言的，我们可以把它理解成边界限定，我会在后面的章节中专门讲解断言（Assertions）相关的内容。"
				}
			]
		},
		{
			"ID": "20230113085240-m03i9j6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085240-m03i9j6",
				"updated": "20230113085252"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113085252-kcyiojh.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113085303-qbqpled",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230113085303-qbqpled",
				"updated": "20230113085303"
			},
			"Children": [
				{
					"ID": "20230113085303-2d4v8dj",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20230113085303-2d4v8dj",
						"updated": "20230113085303"
					},
					"Children": [
						{
							"ID": "20230113085303-55m4r04",
							"Type": "NodeHeading",
							"HeadingLevel": 3,
							"Properties": {
								"id": "20230113085303-55m4r04",
								"updated": "20230113085303"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "特殊单字符"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230113085320-k0qv2xj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085320-k0qv2xj",
				"updated": "20230113085321"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "首先，我们来看下表示特殊单个字符的元字符，比如英文的点（.）表示换行以外的任意单个字符，\\d 表示任意单个数字，\\w 表示任意单个数字或字母或下划线，\\s 表示任意单个空白符。另外，还有与之对应的三个 \\D、\\W 和 \\S，分别表示着和原来相反的意思。"
				}
			]
		},
		{
			"ID": "20230113085322-icp72o0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085322-icp72o0",
				"updated": "20230113085326"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113085326-1haisy8.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113085331-pz7dp20",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085331-pz7dp20",
				"updated": "20230113085335"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "现在我们来看一下测试，我把常见数字，字母，部分标点符号作为文本，用 \\d 去查找，可以看到只能匹配上 10 个数字。"
				}
			]
		},
		{
			"ID": "20230113085336-h7q7927",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085336-h7q7927",
				"updated": "20230113085339"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113085339-gl5rh4t.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113085341-mim0byf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085341-mim0byf",
				"updated": "20230113085352"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "元字符 \\w 能匹配所有的数字、字母和下划线，如下图所示："
				}
			]
		},
		{
			"ID": "20230113085352-sv4532s",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085352-sv4532s",
				"updated": "20230113085356"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113085356-o7oxsit.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113085407-rdb8r2y",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230113085407-rdb8r2y",
				"updated": "20230113085407"
			},
			"Children": [
				{
					"ID": "20230113085407-vhnlyyt",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"fold": "1",
						"id": "20230113085407-vhnlyyt",
						"updated": "20230113085407"
					},
					"Children": [
						{
							"ID": "20230113085407-by8bpw5",
							"Type": "NodeHeading",
							"HeadingLevel": 3,
							"Properties": {
								"id": "20230113085407-by8bpw5",
								"updated": "20230113085407"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "空白符"
								}
							]
						},
						{
							"ID": "20230113085410-m90qnad",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230113085410-m90qnad"
							}
						}
					]
				}
			]
		},
		{
			"ID": "20230113085420-tzdlqq9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085420-tzdlqq9",
				"updated": "20230113085423"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "除了特殊单字符外，你在处理文本的时候肯定还会遇到空格、换行等空白符。其实在写代码的时候也会经常用到，换行符 \\n，TAB 制表符 \\t 等。"
				}
			]
		},
		{
			"ID": "20230113085425-r0xestc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085425-r0xestc",
				"updated": "20230113085431"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "有编程经验的程序员肯定都知道，不同的系统在每行文本结束位置默认的“换行”会有区别。比如在 Windows 里是 \\r\\n，在 Linux 和 MacOS 中是 \\n。"
				}
			]
		},
		{
			"ID": "20230113085431-7ho8b17",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085431-7ho8b17",
				"updated": "20230113085436"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在正则中，也是类似于 \\n 或 \\r 等方式来表示空白符号，只要记住它们就行了。平时使用正则，大部分场景使用 \\s 就可以满足需求，\\s 代表任意单个空白符号。"
				}
			]
		},
		{
			"ID": "20230113085440-kf96d38",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085440-kf96d38",
				"updated": "20230113085441"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113085440-et3lk6y.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113085446-2w9bnxr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085446-2w9bnxr",
				"updated": "20230113085446"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们可以看到， \\s 能匹配上各种空白符号，也可以匹配上空格。换行有专门的表示方式，在正则中，空格就是用普通的字符英文的空格来表示。"
				}
			]
		},
		{
			"ID": "20230113085451-988psht",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230113085451-988psht",
				"updated": "20230113085451"
			},
			"Children": [
				{
					"ID": "20230113085451-kp0juri",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20230113085451-kp0juri",
						"updated": "20230113085451"
					},
					"Children": [
						{
							"ID": "20230113085451-rrw5r8z",
							"Type": "NodeHeading",
							"HeadingLevel": 3,
							"Properties": {
								"id": "20230113085451-rrw5r8z",
								"updated": "20230113085451"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "量词"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230113085503-ye0xaku",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085503-ye0xaku",
				"updated": "20230113085505"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "刚刚我们说到的“基础”的元字符也好，“空白符”也好，它们都只能匹配单个字符，比如\\d 只能匹配一个数字。但更多时候，我们需要匹配单个字符，或者某个部分“重复 N 次”“至少出现一次”“最多出现三次”等等这样的字符，这个时候该怎么办呢？"
				}
			]
		},
		{
			"ID": "20230113085510-8dn38ww",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085510-8dn38ww",
				"updated": "20230113085515"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这就需要用到表示量词的元字符了。"
				}
			]
		},
		{
			"ID": "20230113085515-h7ditma",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085515-h7ditma",
				"updated": "20230113085520"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在正则中，英文的星号（*）代表出现 0 到多次，加号（+）代表 1 到多次，问号（?）代表 0 到 1 次，{m,n}代表 m 到 n 次。"
				}
			]
		},
		{
			"ID": "20230113085521-kh18t7d",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085521-kh18t7d",
				"updated": "20230113085525"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113085525-wk1et7m.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113085528-ayxaiob",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085528-ayxaiob",
				"updated": "20230113085532"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "比如，在文本中“颜色”这个单词，可能是带有 u 的 colour，也可能是不带 u 的 color，我们使用 colou?r 就可以表示两种情况了。在真实的业务场景中，比如某个日志需要添加了一个 user 字段，但在旧日志中，这个是没有的，那么这时候可以使用问号来表示出现 0 次或 1 次，这样就可以表示 user 字段存在和不存在两种情况。"
				}
			]
		},
		{
			"ID": "20230113085533-gbvbvw8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085533-gbvbvw8",
				"updated": "20230113085538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "下面这段文本由三行数字组成，当我们使用 \\d+ 时，能匹配上 3 个，但使用 \\d* 时能匹配上 6 个，详细匹配结果可以参考下面的图片："
				}
			]
		},
		{
			"ID": "20230113085539-m6wt90j",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085539-m6wt90j",
				"updated": "20230113085542"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113085542-uj8f6pp.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113085551-0xdi1v6",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230113085551-0xdi1v6",
				"updated": "20230113085551"
			},
			"Children": [
				{
					"ID": "20230113085551-lvkpgqu",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20230113085551-lvkpgqu",
						"updated": "20230113085551"
					},
					"Children": [
						{
							"ID": "20230113085551-j88sk09",
							"Type": "NodeHeading",
							"HeadingLevel": 3,
							"Properties": {
								"id": "20230113085551-j88sk09",
								"updated": "20230113085551"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "范围"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230113085552-bh6smrf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085552-bh6smrf",
				"updated": "20230113085558"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "学习了量词，我们就可以用 \\d{11} 去匹配所有手机号，但同时也要明白，这个范围比较大，有一些不是手机号的数字也会被匹配上，比如 11 个 0，那么我们就需要在一个特殊的范围里找符合要求的数字。"
				}
			]
		},
		{
			"ID": "20230113085602-oij35zc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085602-oij35zc",
				"updated": "20230113085602"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "再比如，我们要找出所有元音字母 aeiou 的个数，这又要如何实现呢？在正则表达式中，表示范围的元字符可以轻松帮我们搞定这样的问题。"
				}
			]
		},
		{
			"ID": "20230113085603-k8iaa2e",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085603-k8iaa2e",
				"updated": "20230113085607"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在正则表达式中，表示范围的符号有四个分类，如下图所示。"
				}
			]
		},
		{
			"ID": "20230113085607-lryypom",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085607-lryypom",
				"updated": "20230113085611"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113085611-60by3av.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113085612-hu5uuh2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085612-hu5uuh2",
				"updated": "20230113085616"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "首先是管道符号，我们用它来隔开多个正则，表示满足其中任意一个就行，比如 ab|bc 能匹配上 ab，也能匹配上 bc，在正则有多种情况时，这个非常有用。"
				}
			]
		},
		{
			"ID": "20230113085616-glpdn7i",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085616-glpdn7i",
				"updated": "20230113085620"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "中括号[]代表多选一，可以表示里面的任意单个字符，所以任意元音字母可以用 [aeiou] 来表示。另外，中括号中，我们还可以用中划线表示范围，比如 [a-z] 可以表示所有小写字母。如果中括号第一个是脱字符（^），那么就表示非，表达的是不能是里面的任何单个元素。"
				}
			]
		},
		{
			"ID": "20230113085621-01xratt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085621-01xratt",
				"updated": "20230113085626"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "比如某个资源可能以 http:// 开头，或者 https:// 开头，也可能以 ftp:// 开头，那么资源的协议部分，我们可以使用 (https?|ftp):// 来表示。"
				}
			]
		},
		{
			"ID": "20230113085626-pxcl3tc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085626-pxcl3tc",
				"updated": "20230113085644"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113085644-g4etswj.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113085644-qxiizns",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113085644-qxiizns",
				"updated": "20230113085659"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "总结"
				}
			]
		},
		{
			"ID": "20230113085736-jnc99t8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085736-jnc99t8",
				"updated": "20230113085736"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "第 1 位固定为数字 1；第 2 位可能是 3，4，5，6，7，8，9；第 3 位到第 11 位我们认为可能是 0-9 任意数字。"
				}
			]
		},
		{
			"ID": "20230113085738-a2gvgiw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085738-a2gvgiw",
				"updated": "20230113085743"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "写出一个“更严谨”的正则来表示手机号呢？"
				}
			]
		},
		{
			"ID": "20230113085702-8kttfyd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113085702-8kttfyd",
				"updated": "20230113085703"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113085703-4sicsuu.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113085747-ddofdeg",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230113085747-ddofdeg",
				"updated": "20230113100736"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2、贪婪、非贪婪与独占模式贪婪匹配（Greedy）"
				}
			]
		},
		{
			"ID": "20230113091119-44ukyg4",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113091119-44ukyg4",
				"updated": "20230113091119"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "贪婪匹配（Greedy）"
				}
			]
		},
		{
			"ID": "20230113090438-3a2x60t",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113090438-3a2x60t",
				"updated": "20230113090451"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "首先，我们来看一下贪婪匹配。在正则中，表示次数的量词默认是贪婪的，在贪婪模式下，会尝试尽可能最大长度去匹配"
				}
			]
		},
		{
			"ID": "20230113090452-1zia006",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113090452-1zia006",
				"updated": "20230113090458"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "首先，我们来看一下在字符串 aaabb 中使用正则 a* 的匹配过程。"
				}
			]
		},
		{
			"ID": "20230113090506-set9usz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113090506-set9usz",
				"updated": "20230113090510"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113090510-93dejc5.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113090458-umyp92w",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113090458-umyp92w",
				"updated": "20230113090502"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113090502-2t6pgui.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113090505-jsr24jj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113090505-jsr24jj",
				"updated": "20230113090517"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "a* 在匹配开头的 a 时，会尝试尽量匹配更多的 a，直到第一个字母 b 不满足要求为止，匹配上三个 a，后面每次匹配时都得到了空字符串。"
				}
			]
		},
		{
			"ID": "20230113090520-zluf5lf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113090520-zluf5lf",
				"updated": "20230113090521"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "相信看到这里你也发现了，贪婪模式的特点就是尽可能进行最大长度匹配。所以要不要使用贪婪模式是根据需求场景来定的。如果我们想尽可能最短匹配呢？那就要用到非贪婪匹配模式了。"
				}
			]
		},
		{
			"ID": "20230113090522-nludprz",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113090522-nludprz",
				"updated": "20230113090528"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "非贪婪匹配（Lazy）"
				}
			]
		},
		{
			"ID": "20230113090533-i6q7y77",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113090533-i6q7y77",
				"updated": "20230113090538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "那么如何将贪婪模式变成非贪婪模式呢？我们可以在量词后面加上英文的问号 (?)，正则就变成了 a*?。此时的匹配结果如下："
				}
			]
		},
		{
			"ID": "20230113090538-t26h7n6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113090538-t26h7n6",
				"updated": "20230113090542"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113090542-5kzm9kl.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113090543-sjdm957",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113090543-sjdm957",
				"updated": "20230113090553"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这一次我们可以看到，这次匹配到的结果都是单个的 a，就连每个 a 左边的空字符串也匹配上了。"
				}
			]
		},
		{
			"ID": "20230113090553-qgzikv1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113090553-qgzikv1",
				"updated": "20230113090557"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这一次我们可以看到，这次匹配到的结果都是单个的 a，就连每个 a 左边的空字符串也匹配上了。"
				}
			]
		},
		{
			"ID": "20230113090558-iqd4lz6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113090558-iqd4lz6",
				"updated": "20230113090605"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "到这里你可能就明白了，非贪婪模式会尽可能短地去匹配，我把这两者之间的区别写到了下面这张图中。"
				}
			]
		},
		{
			"ID": "20230113090605-vsb9w6u",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113090605-vsb9w6u",
				"updated": "20230113090609"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113090609-cdbuh1v.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113090609-u72p2n8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113090609-u72p2n8",
				"updated": "20230113090615"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "为了让你加深理解，我们再来看一个示例，这一次让我们查找一下引号中的单词。"
				}
			]
		},
		{
			"ID": "20230113090624-z2cgoed",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113090624-z2cgoed",
				"updated": "20230113090628"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "从下面这个示例中，我们可以很容易看出两者对比上的差异。左右的文本是一样的，其中有两对双引号。不同之处在于，左边的示例中，不加问号时正则是贪婪匹配，匹配上了从第一个引号到最后一个引号之间的所有内容；而右边的图是非贪婪匹配，找到了符合要求的结果。"
				}
			]
		},
		{
			"ID": "20230113090629-gilrpqs",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113090629-gilrpqs",
				"updated": "20230113090632"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113090632-3gp4bk7.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113090632-l752wbf",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113090632-l752wbf",
				"updated": "20230113090637"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "独占模式（Possessive）"
				}
			]
		},
		{
			"ID": "20230113090639-v0g19yc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113090639-v0g19yc",
				"updated": "20230113090644"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "不管是贪婪模式，还是非贪婪模式，都需要发生回溯才能完成相应的功能。但是在一些场景下，我们不需要回溯，匹配不上返回失败就好了，因此正则中还有另外一种模式，独占模式，它类似贪婪匹配，但匹配过程不会发生回溯，因此在一些场合下性能会更好。"
				}
			]
		},
		{
			"ID": "20230113090644-uid6n2d",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113090644-uid6n2d",
				"updated": "20230113090648"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "你可能会问，那什么是回溯呢？我们来看一些例子，例如下面的正则："
				}
			]
		},
		{
			"ID": "20230113090829-vedlivs",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113090829-vedlivs",
				"updated": "20230113090935"
			},
			"Children": [
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "regex = “xy{1,3}z”"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				}
			]
		},
		{
			"ID": "20230113090857-1sxeb7u",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113090857-1sxeb7u",
				"updated": "20230113090948"
			},
			"Children": [
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "text = “xyyz”"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				}
			]
		},
		{
			"ID": "20230113090902-jrg81xw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113090902-jrg81xw",
				"updated": "20230113090955"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在匹配时，y{1,3}会尽可能长地去匹配，当匹配完 xyy 后，由于 y 要尽可能匹配最长，即三个，但字符串中后面是个 z 就会导致匹配不上，这时候正则就会向前回溯，吐出当前字符 z，接着用正则中的 z 去匹配。"
				}
			]
		},
		{
			"ID": "20230113090958-zfngfjz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113090958-zfngfjz",
				"updated": "20230113090959"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113090959-dyyxo7g.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113091003-t7j160k",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091003-t7j160k",
				"updated": "20230113091004"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果我们把这个正则改成非贪婪模式，如下："
				}
			]
		},
		{
			"ID": "20230113091005-1xhquc9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091005-1xhquc9",
				"updated": "20230113091014"
			},
			"Children": [
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "regex = “xy{1,3}?z”"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				}
			]
		},
		{
			"ID": "20230113091009-h1b1dyp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091009-h1b1dyp",
				"updated": "20230113091015"
			},
			"Children": [
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "text = “xyyz”"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				}
			]
		},
		{
			"ID": "20230113091016-evpe3j6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091016-evpe3j6",
				"updated": "20230113091019"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "由于 y{1,3}? 代表匹配 1 到 3 个 y，尽可能少地匹配。匹配上一个 y 之后，也就是在匹配上 text 中的 xy 后，正则会使用 z 和 text 中的 xy 后面的 y 比较，发现正则 z 和 y 不匹配，这时正则就会向前回溯，重新查看 y 匹配两个的情况，匹配上正则中的 xyy，然后再用 z 去匹配 text 中的 z，匹配成功。"
				}
			]
		},
		{
			"ID": "20230113091020-o02800j",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091020-o02800j",
				"updated": "20230113091024"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113091024-jmus6g7.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113091037-nr2rawo",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091037-nr2rawo",
				"updated": "20230113091150"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "独占模式和贪婪模式很像，独占模式会尽可能多地去匹配，如果匹配失败就结束，不会进行回溯，这样的话就比较节省时间。具体的方法就是在量词后面加上加号（+）。"
				}
			]
		},
		{
			"ID": "20230113091209-q7mz7br",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091209-q7mz7br",
				"updated": "20230113091259"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果你用 a{1,3}+ab 去匹配 aaab 字符串，a{1,3}+ 会把前面三个 a 都用掉，并且不会回溯，这样字符串中内容只剩下 b 了，导致正则中加号后面的 a 匹配不到符合要求的内容，匹配失败。如果是贪婪模式 a{1,3} 或非贪婪模式 a{1,3}? 都可以匹配上。"
				}
			]
		},
		{
			"ID": "20230113091259-9qcyt10",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091259-9qcyt10",
				"updated": "20230113091302"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113091302-fvbzkwb.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113091349-3l7l41z",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113091349-3l7l41z",
				"updated": "20230113091414"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "总结"
				}
			]
		},
		{
			"ID": "20230113091415-xvk840f",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091415-xvk840f",
				"updated": "20230113091434"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "正则中量词默认是贪婪匹配，如果想要进行非贪婪匹配需要在量词后面加上问号。贪婪和非贪婪匹配都可能会进行回溯，独占模式也是进行贪婪匹配，但不进行回溯，因此在一些场景下，可以提高匹配的效率，具体能不能用独占模式需要看使用的编程语言的类库的支持情况，以及独占模式能不能满足需求。"
				}
			]
		},
		{
			"ID": "20230113091455-9fyrmo1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091455-9fyrmo1",
				"updated": "20230113091520"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "有一篇英文文章，里面有很多单词，单词和单词之间是用空格隔开的，在引号里面的一到多个单词表示特殊含义，即引号里面的多个单词要看成一个单词。现在你需要提取出文章中所有的单词。我们可以假设文章中除了引号没有其它的标点符号，有什么方法可以解决这个问题呢？如果用正则来解决，你能不能写出一个正则，提取出文章中所有的单词呢（不要求结果去重）？"
				}
			]
		},
		{
			"ID": "20230113091521-loprtse",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091521-loprtse",
				"updated": "20230113091530"
			},
			"Children": [
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "we found “the little cat” is in the hat, we like “the little cat”"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113091536-4fzzjjs",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091536-4fzzjjs",
				"updated": "20230113091539"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "其中 the little cat 需要看成一个单词"
				}
			]
		},
		{
			"ID": "20230113091435-y6gso7t",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091435-y6gso7t",
				"updated": "20230113091438"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113091438-4a0mta7.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113092211-e6doeat",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230113092211-e6doeat",
				"updated": "20230113100739"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3、分组与引用"
				}
			]
		},
		{
			"ID": "20230113091627-ktdxhl8",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113091627-ktdxhl8",
				"updated": "20230113091632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "分组与编号"
				}
			]
		},
		{
			"ID": "20230113091634-9ic9oef",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091634-9ic9oef",
				"updated": "20230113091657"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "括号在正则中可以用于分组，被括号括起来的部分“子表达式”会被保存成一个子组。"
				}
			]
		},
		{
			"ID": "20230113091658-8zntqz1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091658-8zntqz1",
				"updated": "20230113091705"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "那分组和编号的规则是怎样的呢？其实很简单，用一句话来说就是，第几个括号就是第几个分组。这么说可能不好理解，我们来举一个例子看一下。"
				}
			]
		},
		{
			"ID": "20230113091705-o2nmb2d",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091705-o2nmb2d",
				"updated": "20230113091709"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这里有个时间格式 2020-05-10 20:23:05。假设我们想要使用正则提取出里面的日期和时间。"
				}
			]
		},
		{
			"ID": "20230113091710-aqb922x",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091710-aqb922x",
				"updated": "20230113091713"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113091713-l2w6szn.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113091714-88pqc1n",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091714-88pqc1n",
				"updated": "20230113091720"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们可以写出如图所示的正则，将日期和时间都括号括起来。这个正则中一共有两个分组，日期是第 1 个，时间是第 2 个。"
				}
			]
		},
		{
			"ID": "20230113091720-9tvokli",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113091720-9tvokli",
				"updated": "20230113091724"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "不保存子组"
				}
			]
		},
		{
			"ID": "20230113091725-0nibug9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091725-0nibug9",
				"updated": "20230113091729"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在括号里面的会保存成子组，但有些情况下，你可能只想用括号将某些部分看成一个整体，后续不用再用它，类似这种情况，在实际使用时，是没必要保存子组的。这时我们可以在括号里面使用 ?: 不保存子组。"
				}
			]
		},
		{
			"ID": "20230113091730-1emdt31",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091730-1emdt31",
				"updated": "20230113091735"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果正则中出现了括号，那么我们就认为，这个子表达式在后续可能会再次被引用，所以不保存子组可以提高正则的性能。除此之外呢，这么做还有一些好处，由于子组变少了，正则性能会更好，在子组计数时也更不容易出错。"
				}
			]
		},
		{
			"ID": "20230113091736-pmw0imy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091736-pmw0imy",
				"updated": "20230113091741"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "那到底啥是不保存子组呢？我们可以理解成，括号只用于归组，把某个部分当成“单个元素”，不分配编号，后面不会再进行这部分的引用。"
				}
			]
		},
		{
			"ID": "20230113091745-6615eu0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091745-6615eu0",
				"updated": "20230113091745"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113091745-yg6gktm.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113091748-tygykr5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091748-tygykr5",
				"updated": "20230113091748"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113091748-zb5np3y.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113091751-n6pni0q",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113091751-n6pni0q",
				"updated": "20230113091755"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "括号嵌套"
				}
			]
		},
		{
			"ID": "20230113091755-z9nkktk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091755-z9nkktk",
				"updated": "20230113091801"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "前面讲完了子组和编号，但有些情况会比较复杂，比如在括号嵌套的情况里，我们要看某个括号里面的内容是第几个分组怎么办？不要担心，其实方法很简单，我们只需要数左括号（开括号）是第几个，就可以确定是第几个子组。"
				}
			]
		},
		{
			"ID": "20230113091806-6cbld4c",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091806-6cbld4c",
				"updated": "20230113091806"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在阿里云简单日志系统中，我们可以使用正则来匹配一行日志的行首。假设时间格式是 2020-05-10 20:23:05 。"
				}
			]
		},
		{
			"ID": "20230113091807-0fzpimq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091807-0fzpimq",
				"updated": "20230113091810"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113091810-jesn1rs.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113091811-8oflpdv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091811-8oflpdv",
				"updated": "20230113091815"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "日期分组编号是 1，时间分组编号是 5，年月日对应的分组编号分别是 2，3，4，时分秒的分组编号分别是 6，7，8。"
				}
			]
		},
		{
			"ID": "20230113091820-inmj8vn",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113091820-inmj8vn"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "命名分组"
				}
			]
		},
		{
			"ID": "20230113091823-tn0vqxn",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091823-tn0vqxn",
				"updated": "20230113091853"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "前面我们讲了分组编号，但由于编号得数在第几个位置，后续如果发现正则有问题，改动了括号的个数，还可能导致编号发生变化，因此一些编程语言提供了命名分组（named grouping），这样和数字相比更容易辨识，不容易出错。命名分组的格式为"
				},
				{
					"Type": "NodeMark",
					"Data": "mark",
					"Children": [
						{
							"Type": "NodeMark2OpenMarker"
						},
						{
							"Type": "NodeText",
							"Data": "(?P\u003c分组名\u003e正则)"
						},
						{
							"Type": "NodeMark2CloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20230113091833-pshsclf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091833-pshsclf",
				"updated": "20230113091842"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "需要注意的是，刚刚提到的方式命名分组和前面一样，给这个分组分配一个编号，不过你可以使用名称，不用编号，实际上命名分组的编号已经分配好了。不过命名分组并不是所有语言都支持的，在使用时，你需要查阅所用语言正则说明文档，如果支持，那你才可以使用。"
				}
			]
		},
		{
			"ID": "20230113091842-n727cfv",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113091842-n727cfv",
				"updated": "20230113091859"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "分组引用"
				}
			]
		},
		{
			"ID": "20230113091900-zfgrkq7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091900-zfgrkq7",
				"updated": "20230113091912"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在知道了分组引用的编号 （number）后，大部分情况下，我们就可以使用 “反斜扛 + 编号”，即 \\number 的方式来进行引用，而 JavaScript 中是通过"
				},
				{
					"Type": "NodeInlineMath",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeInlineMathOpenMarker"
						},
						{
							"Type": "NodeInlineMathContent",
							"Data": "编号来引用，如"
						},
						{
							"Type": "NodeInlineMathCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "1。"
				}
			]
		},
		{
			"ID": "20230113091913-8mw4ifo",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091913-8mw4ifo",
				"updated": "20230113091924"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我给到了你一些在常见的编程语言中，分组查找和替换的引用方式："
				}
			]
		},
		{
			"ID": "20230113091925-gy23g14",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091925-gy23g14",
				"updated": "20230113091928"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113091928-gwajizs.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113091928-jqwt0mf",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113091928-jqwt0mf",
				"updated": "20230113091936"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "分组引用在查找中使用"
				}
			]
		},
		{
			"ID": "20230113091937-kuz4rhz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091937-kuz4rhz",
				"updated": "20230113091942"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "前面介绍了子组和引用的基本知识，现在我们来看下在正则查找时如何使用分组引用。比如我们要找重复出现的单词，我们使用正则可以很方便地使“前面出现的单词再次出现”，具体要怎么操作呢？我们可以使用 \\w+ 来表示一个单词，针对刚刚的问题，我们就可以很容易写出 (\\w+) \\1 这个正则表达式了。"
				}
			]
		},
		{
			"ID": "20230113091943-ywrl33z",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091943-ywrl33z",
				"updated": "20230113091946"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113091945-z1bs20f.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113091946-y0v0ufj",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113091946-y0v0ufj",
				"updated": "20230113091954"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "分组引用在替换中使用"
				}
			]
		},
		{
			"ID": "20230113091955-2zlvius",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091955-2zlvius",
				"updated": "20230113091959"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "和查找类似，我们可以使用反向引用，在得到的结果中，去拼出来我们想要的结果。还是使用刚刚日期时间的例子，我们可以很方便地将它替换成， 2020 年 05 月 10 日这样的格式。"
				}
			]
		},
		{
			"ID": "20230113092000-nznlnqg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113092000-nznlnqg",
				"updated": "20230113092004"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113092004-5hgl9an.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113092005-omvqm74",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113092005-omvqm74",
				"updated": "20230113092025"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "总结"
				}
			]
		},
		{
			"ID": "20230113092027-b731zhr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113092027-b731zhr",
				"updated": "20230113092104"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "做一个小练习吧。有一篇英文文章，里面有一些单词连续出现了多次，我们认为连续出现多次的单词应该是一次，比如："
				}
			]
		},
		{
			"ID": "20230113092105-2xk19es",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113092105-2xk19es",
				"updated": "20230113092111"
			},
			"Children": [
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "the little cat cat is in the hat hat hat, we like it."
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				}
			]
		},
		{
			"ID": "20230113092113-32srvw6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113092113-32srvw6",
				"updated": "20230113092116"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "其中 cat 和 hat 连接出现多次，要求处理后结果是"
				}
			]
		},
		{
			"ID": "20230113092117-etmbeio",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113092117-etmbeio",
				"updated": "20230113092122"
			},
			"Children": [
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "the little cat is in the hat, we like it."
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				}
			]
		},
		{
			"ID": "20230113091815-ffeihcr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113091815-ffeihcr",
				"updated": "20230113092035"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113092035-nwvuen4.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113092156-87p58ci",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230113092156-87p58ci",
				"updated": "20230113100742"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "4、4种匹配模式"
				}
			]
		},
		{
			"ID": "20230113092156-fvxm5jv",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113092156-fvxm5jv",
				"updated": "20230113092336"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "不区分大小写模式（Case-Insensitive）"
				}
			]
		},
		{
			"ID": "20230113092337-27nai31",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113092337-27nai31",
				"updated": "20230113092350"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在进行文本匹配时，我们要关心单词本身的意义。比如要查找单词 cat，我们并不需要关心单词是 CAT、Cat，还是 cat。根据之前我们学到的知识，你可能会把正则写成这样：[Cc][Aa][Tt]，这样写虽然可以达到目的，但不够直观，如果单词比较长，写起来容易出错，阅读起来也比较困难。"
				}
			]
		},
		{
			"ID": "20230113092350-ga8xovg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113092350-ga8xovg",
				"updated": "20230113092354"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113092354-aag5359.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113092355-0ofm669",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113092355-0ofm669",
				"updated": "20230113092411"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "不区分大小写是匹配模式的一种。当我们把模式修饰符放在整个正则前面时，就表示整个正则表达式都是不区分大小写的。模式修饰符是通过 (? 模式标识) 的方式来表示的。  我们只需要把模式修饰符放在对应的正则前，就可以使用指定的模式了。在不区分大小写模式中，由于不分大小写的英文是 Case-Insensitive，那么对应的模式标识就是 I 的小写字母 i，所以不区分大小写的 cat 就可以写成  (?i)cat。"
				}
			]
		},
		{
			"ID": "20230113092411-pktntvp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113092411-pktntvp",
				"updated": "20230113092415"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113092415-vsj3thr.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113092415-bxdp1x5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113092415-bxdp1x5",
				"updated": "20230113092421"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "和[Cc][Aa][Tt] 相比，这样是不是清晰简洁了很多呢？"
				}
			]
		},
		{
			"ID": "20230113092423-p350u2b",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113092423-p350u2b",
				"updated": "20230113092427"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们也可以用它来尝试匹配两个连续出现的 cat，如下图所示，你会发现，即便是第一个 cat 和第二个 cat 大小写不一致，也可以匹配上。"
				}
			]
		},
		{
			"ID": "20230113092428-qsmi5eq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113092428-qsmi5eq",
				"updated": "20230113092431"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113092431-h0lf4bl.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113092432-51iwvza",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113092432-51iwvza",
				"updated": "20230113092450"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果我们想要前面匹配上的结果，和第二次重复时的大小写一致，那该怎么做呢？我们只需要用括号把修饰符和正则 cat 部分括起来，加括号相当于作用范围的限定，让不区分大小写只作用于这个括号里的内容。"
				}
			]
		},
		{
			"ID": "20230113092451-jxlb1v7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113092451-jxlb1v7",
				"updated": "20230113092455"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113092455-if45a95.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113092455-5fb9o50",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113092455-5fb9o50",
				"updated": "20230113092541"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "需要注意的是，这里正则写成了 ((?i)cat) \\1，而不是 ((?i)(cat)) \\1。也就是说，我们给修饰符和 cat 整体加了个括号，而原来 cat 部分的括号去掉了。如果 cat 保留原来的括号，即 ((?i)(cat)) \\1，这样正则中就会有两个子组，虽然结果也是对的"
				}
			]
		},
		{
			"ID": "20230113092549-6jc8jkn",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113092549-6jc8jkn",
				"updated": "20230113092610"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们再进阶一下。如果用正则匹配，实现部分区分大小写，另一部分不区分大小写，这该如何操作呢？就比如说我现在想要，the cat 中的 the 不区分大小写，cat 区分大小写。"
				}
			]
		},
		{
			"ID": "20230113092610-nfm1nkl",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113092610-nfm1nkl",
				"updated": "20230113092622"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "你应该能很快写出相应的正则，也就是 ((?i)the) cat。实现的效果如下"
				}
			]
		},
		{
			"ID": "20230113092630-jn72o6u",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113092630-jn72o6u",
				"updated": "20230113092634"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113092634-9wtuw4k.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113092634-nu3bwaf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113092634-nu3bwaf",
				"updated": "20230113092651"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "到这里我简单总结一下不区分大小写模式的要点："
				}
			]
		},
		{
			"ID": "20230113092728-15cji85",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230113092728-15cji85",
				"updated": "20230113092728"
			},
			"Children": [
				{
					"ID": "20230113092728-ystx5ip",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230113092728-ystx5ip",
						"updated": "20230113092728"
					},
					"Children": [
						{
							"ID": "20230113092728-dup7aky",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230113092728-dup7aky",
								"updated": "20230113092732"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "不区分大小写模式的指定方式，使用模式修饰符 (?i)；"
								}
							]
						}
					]
				},
				{
					"ID": "20230113092737-73zcjad",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230113092737-73zcjad"
					},
					"Children": [
						{
							"ID": "20230113092737-0jq7on7",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230113092737-0jq7on7",
								"updated": "20230113092739"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "修饰符如果在括号内，作用范围是这个括号内的正则，而不是整个正则；"
								}
							]
						}
					]
				},
				{
					"ID": "20230113092740-vqz73g5",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230113092740-vqz73g5"
					},
					"Children": [
						{
							"ID": "20230113092740-nlegmdw",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230113092740-nlegmdw",
								"updated": "20230113092743"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "使用编程语言时可以使用预定义好的常量来指定匹配模式。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230113092747-wb671ty",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113092747-wb671ty",
				"updated": "20230113092759"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "点号通配模式（Dot All）"
				}
			]
		},
		{
			"ID": "20230113092801-8q91g6c",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113092801-8q91g6c",
				"updated": "20230113092817"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在基础篇的第一讲里，我为你讲解了元字符相关的知识，你还记得英文的点（.）有什么用吗？它可以匹配上任何符号，但不能匹配换行。当我们需要匹配真正的“任意”符号的时候，可以使用 [\\s\\S] 或 [\\d\\D] 或 [\\w\\W] 等。"
				}
			]
		},
		{
			"ID": "20230113092817-jx5okqn",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113092817-jx5okqn",
				"updated": "20230113092821"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113085326-1haisy8.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113092823-7tj9p7u",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113092823-7tj9p7u",
				"updated": "20230113092830"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这个模式就是点号通配模式，有很多地方把它称作单行匹配模式，但这么说容易造成误解，毕竟它与多行匹配模式没有联系，因此在课程中我们统一用更容易理解的“点号通配模式”"
				}
			]
		},
		{
			"ID": "20230113092831-0og5u2h",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113092831-0og5u2h",
				"updated": "20230113092843"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "单行模式对应的修饰符是 (?s)，我还是选择用 the cat 来给你举一个点号通配模式的例子。如下图所示："
				}
			]
		},
		{
			"ID": "20230113092844-yvacnwm",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113092844-yvacnwm",
				"updated": "20230113092847"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113092847-7tckh77.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113092847-d2dtcsm",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113092847-d2dtcsm",
				"updated": "20230113092858"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "需要注意的是，JavaScript 不支持此模式，那么我们就可以使用前面说的[\\s\\S]等方式替代。在 Ruby 中则是用 Multiline，来表示点号通配模式（单行匹配模式），我猜测设计者的意图是把点（.）号理解成“能匹配多行”。"
				}
			]
		},
		{
			"ID": "20230113092858-7qg1a0a",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113092858-7qg1a0a",
				"updated": "20230113093025"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "多行匹配模式（Multiline）"
				}
			]
		},
		{
			"ID": "20230113092905-czqsp85",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113092905-czqsp85",
				"updated": "20230113093135"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "讲完了点号通配模式，我们再来看看多行匹配模式。通常情况下，^匹配整个字符串的开头，$ 匹配整个字符串的结尾。多行匹配模式改变的就是 ^ 和  的匹配行为。"
				}
			]
		},
		{
			"ID": "20230113092944-2jqe5ui",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113092944-2jqe5ui",
				"updated": "20230113093209"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113093209-iwr7h8h.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113093210-0fhej5j",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113093210-0fhej5j",
				"updated": "20230113093216"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "多行模式的作用在于，使 ^ 和 $ 能匹配上每行的开头或结尾，我们可以使用模式修饰符号 (?m) 来指定这个模式。"
				}
			]
		},
		{
			"ID": "20230113093216-j458m73",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113093216-j458m73",
				"updated": "20230113093220"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113093220-4f4491c.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113093221-q1go1kd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113093221-q1go1kd",
				"updated": "20230113093225"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这个模式有什么用呢？在处理日志时，如果日志以时间开头，有一些日志打印了堆栈信息，占用了多行，我们就可以使用多行匹配模式，在日志中匹配到以时间开头的每一行日志。"
				}
			]
		},
		{
			"ID": "20230113093225-ke9svni",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113093225-ke9svni",
				"updated": "20230113093231"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "注释模式（Comment）"
				}
			]
		},
		{
			"ID": "20230113093232-ip95lmg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113093232-ip95lmg",
				"updated": "20230113093237"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在实际工作中，正则可能会很复杂，这就导致编写、阅读和维护正则都会很困难。我们在写代码的时候，通常会在一些关键的地方加上注释，让代码更易于理解。很多语言也支持在正则中添加注释，让正则更容易阅读和维护，这就是正则的注释模式。正则中注释模式是使用 (?#comment) 来表示。"
				}
			]
		},
		{
			"ID": "20230113093241-ga93i4z",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113093241-ga93i4z",
				"updated": "20230113093258"
			},
			"Children": [
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "(\\w+)(?word repeat again)#word) \\1(?#"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				}
			]
		},
		{
			"ID": "20230113093259-9khwg2d",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113093259-9khwg2d",
				"updated": "20230113093312"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "总结"
				}
			]
		},
		{
			"ID": "20230113093313-9c8iurj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113093313-9c8iurj",
				"updated": "20230113093321"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "正则中常见的四种匹配模式，分别是：不区分大小写、点号通配模式、多行模式和注释模式。"
				}
			]
		},
		{
			"ID": "20230113093326-sxlvn37",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230113093326-sxlvn37",
				"updated": "20230113093347"
			},
			"Children": [
				{
					"ID": "20230113093352-z0ezeq4",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230113093352-z0ezeq4",
						"updated": "20230113093352"
					},
					"Children": [
						{
							"ID": "20230113093352-ydotftw",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230113093352-ydotftw",
								"updated": "20230113093358"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "不区分大小写模式，它可以让整个正则或正则中某一部分进行不区分大小写的匹配。"
								}
							]
						}
					]
				},
				{
					"ID": "20230113093359-fzbjtg2",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230113093359-fzbjtg2"
					},
					"Children": [
						{
							"ID": "20230113093359-09jfaue",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230113093359-09jfaue",
								"updated": "20230113093404"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "点号通配模式也叫单行匹配，改变的是点号的匹配行为，让其可以匹配任何字符，包括换行。"
								}
							]
						}
					]
				},
				{
					"ID": "20230113093405-n5g7dg9",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230113093405-n5g7dg9"
					},
					"Children": [
						{
							"ID": "20230113093405-sjddvsk",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230113093405-sjddvsk",
								"updated": "20230113093410"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "多行匹配说的是 ^ 和 $ 的匹配行为，让其可以匹配上每行的开头或结尾。"
								}
							]
						}
					]
				},
				{
					"ID": "20230113093410-m5pucze",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230113093410-m5pucze"
					},
					"Children": [
						{
							"ID": "20230113093410-uo5mljc",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230113093410-uo5mljc",
								"updated": "20230113093414"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "注释模式则可以在正则中添加注释，让正则变得更容易阅读和维护。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230113093415-zoa5s68",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113093415-zoa5s68",
				"updated": "20230113093418"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113093418-7mx0t5i.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113093432-t25u7jw",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230113093432-t25u7jw",
				"updated": "20230113100745"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "5、断言"
				}
			]
		},
		{
			"ID": "20230113093513-3mqnruu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113093513-3mqnruu",
				"updated": "20230113093520"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "什么是断言呢？简单来说，断言是指对匹配到的文本位置有要求。这么说你可能还是没理解，我通过一些例子来给你讲解。你应该知道 \\d{11} 能匹配上 11 位数字，但这 11 位数字可能是 18 位身份证号中的一部分。再比如，去查找一个单词，我们要查找 tom，但其它的单词，比如 tomorrow 中也包含了 tom。"
				}
			]
		},
		{
			"ID": "20230113093534-thfbrht",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113093534-thfbrht",
				"updated": "20230113093538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "单词边界（Word Boundary）"
				}
			]
		},
		{
			"ID": "20230113093542-x6kb5dt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113093542-x6kb5dt",
				"updated": "20230113093552"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在讲单词边界具体怎么使用前，我们先来看一下例子。我们想要把下面文本中的 tom 替换成 jerry。注意一下，在文本中出现了 tomorrow 这个单词，tomorrow 也是以 tom 开头的。"
				}
			]
		},
		{
			"ID": "20230113093553-hepoqsf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113093553-hepoqsf",
				"updated": "20230113094508"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "单词的组成一般可以用元字符 \\w+ 来表示，\\w 包括了大小写字母、下划线和数字（即 [A-Za-z0-9_]）。那如果我们能找出单词的边界，也就是当出现了"
				},
				{
					"Type": "NodeMark",
					"Data": "mark",
					"Children": [
						{
							"Type": "NodeMark2OpenMarker"
						},
						{
							"Type": "NodeText",
							"Data": "\\w 表示的范围以外"
						},
						{
							"Type": "NodeMark2CloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "的字符，比如引号、空格、标点、换行等这些符号，我们就可以在正则中使用\\b 来表示单词的边界。 \\b 中的 b 可以理解为是边界（Boundary）这个单词的首字母。"
				}
			]
		},
		{
			"ID": "20230113095110-xpt82we",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113095110-xpt82we",
				"updated": "20230113095123"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在准确匹配单词时，我们使用 "
				},
				{
					"Type": "NodeMark",
					"Data": "mark",
					"Children": [
						{
							"Type": "NodeMark2OpenMarker"
						},
						{
							"Type": "NodeText",
							"Data": "\\b\\w+\\b"
						},
						{
							"Type": "NodeMark2CloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 就可以实现了"
				}
			]
		},
		{
			"ID": "20230113093623-jduz27h",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113093623-jduz27h",
				"updated": "20230113093633"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113093633-3iw8hdq.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113093633-r44acmy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113093633-r44acmy",
				"updated": "20230113093724"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "根据刚刚学到的内容，在准确匹配单词时，我们使用 \\b\\w+\\b 就可以实现了。"
				}
			]
		},
		{
			"ID": "20230113093725-p76hewq",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113093725-p76hewq",
				"updated": "20230113094523"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "行的开始或结束"
				}
			]
		},
		{
			"ID": "20230113094525-eqohb4p",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113094525-eqohb4p",
				"updated": "20230113094531"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "和单词的边界类似，在正则中还有文本每行的开始和结束，如果我们要求匹配的内容要出现在一行文本开头或结尾，就可以使用 ^ 和 $ 来进行位置界定"
				}
			]
		},
		{
			"ID": "20230113094531-poty4xe",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113094531-poty4xe",
				"updated": "20230113094609"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们先说一下行的结尾是如何判断的。你应该知道换行符号。在计算机中，回车（\\r）和换行（\\n）其实是两个概念，并且在不同的平台上，换行的表示也是不一样的。linux \\n windows \\r\\n"
				}
			]
		},
		{
			"ID": "20230113094609-ugh1r26",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113094609-ugh1r26",
				"updated": "20230113094615"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "日志起始行判断"
				}
			]
		},
		{
			"ID": "20230113094539-wm9j0hc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113094539-wm9j0hc",
				"updated": "20230113094622"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "最常见的例子就是日志收集，我们在收集日志的时候，通常可以指定日志行的开始规则，比如以时间开头，那些不是以时间开头的可能就是打印的堆栈信息。我来给你一个以日期开头，下面每一行都属于同一篇日志的例子。"
				}
			]
		},
		{
			"ID": "20230113094623-7tg8vmr",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113094623-7tg8vmr",
				"updated": "20230113094955"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "环视（ Look Around）"
				}
			]
		},
		{
			"ID": "20230113094957-oil5axk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113094957-oil5axk",
				"updated": "20230113095252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "那具体什么时候我们会用到环视呢？我来举个例子。邮政编码的规则是由 6 位数字组成。现在要求你写出一个正则，提取文本中的邮政编码。根据规则，我们很容易就可以写出邮编的组成\\d{6}。我们可以使用下面的文本进行测试："
				}
			]
		},
		{
			"ID": "20230113095253-cwn6rg1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113095253-cwn6rg1",
				"updated": "20230113095307"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们发现，7 位数的前 6 位也能匹配上，12 位数匹配上了两次，这显然是不符合要求的。"
				}
			]
		},
		{
			"ID": "20230113095308-jimyhvo",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113095308-jimyhvo",
				"updated": "20230113095310"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113095310-l8n9rpw.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113095311-wfrd043",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113095311-wfrd043",
				"updated": "20230113095321"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "除了文本本身组成符合这 6 位数的规则外，这 6 位数左边或右边都不能是数字。"
				}
			]
		},
		{
			"ID": "20230113095321-0j096ff",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113095321-0j096ff",
				"updated": "20230113095328"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "正则是通过环视来解决这个问题的。解决这个问题的正则有四种。我给你总结了一个表。"
				}
			]
		},
		{
			"ID": "20230113095329-4tn9s5w",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113095329-4tn9s5w",
				"updated": "20230113095357"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113095357-yakoc9t.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113095358-aa8cql1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113095358-aa8cql1",
				"updated": "20230113095410"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "你可能觉得名称比较难记住，没关系，我给你一个小口诀，你只要记住了它的功能和写法就行。这个小口诀你可以在心里默念几遍："
				},
				{
					"Type": "NodeMark",
					"Data": "mark",
					"Children": [
						{
							"Type": "NodeMark2OpenMarker"
						},
						{
							"Type": "NodeText",
							"Data": "左尖括号代表看左边，没有尖括号是看右边，感叹号是非的意思"
						},
						{
							"Type": "NodeMark2CloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20230113095410-ey5frfb",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113095410-ey5frfb",
				"updated": "20230113095430"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "针对刚刚邮编的问题，就可以写成左边不是数字，右边也不是数字的 6 位数的正则。即 (?\u003c!\\d)\\d{6}(?!\\d)。这样就能够符合要求了。"
				}
			]
		},
		{
			"ID": "20230113095432-eca77dt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113095432-eca77dt",
				"updated": "20230113095435"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113095435-jvm9lz5.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113095436-z47zjzk",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113095436-z47zjzk",
				"updated": "20230113095441"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "单词边界用环视表示"
				}
			]
		},
		{
			"ID": "20230113095442-vqma3gz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113095442-vqma3gz",
				"updated": "20230113095452"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "表示单词边界的 \\b 如果用环视的方式来写，应该是怎么写呢？"
				}
			]
		},
		{
			"ID": "20230113095452-bm7evy3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113095452-bm7evy3",
				"updated": "20230113095501"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这个问题其实比较简单，单词可以用 \\w+ 来表示，单词的边界其实就是那些不能组成单词的字符，即左边和右边都不能是组成单词的字符。比如下面这句话："
				}
			]
		},
		{
			"ID": "20230113095501-x0vik92",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113095501-x0vik92",
				"updated": "20230113095508"
			},
			"Children": [
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "the little cat is in the hat"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				}
			]
		},
		{
			"ID": "20230113095508-xo4ynne",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113095508-xo4ynne",
				"updated": "20230113095513"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "the 左侧是行首，右侧是空格，hat 右侧是行尾，左侧是空格，其它单词左右都是空格。所有单词左右都不是 \\w。"
				}
			]
		},
		{
			"ID": "20230113095513-qum2i36",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113095513-qum2i36",
				"updated": "20230113095518"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "(?\u003c!\\w) 表示左边不能是单词组成字符，(?!\\w) 右边不能是单词组成字符，即 \\b\\w+\\b 也可以写成 (?\u003c!\\w)\\w+(?!\\w)。"
				}
			]
		},
		{
			"ID": "20230113095519-sststdn",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113095519-sststdn",
				"updated": "20230113095524"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "另外，根据前面学到的知识，非\\w 也可以用\\W 来表示。那单词的正则可以写成 (?\u003c=\\W)\\w+(?=\\W)。"
				}
			]
		},
		{
			"ID": "20230113095535-7kzqux4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113095535-7kzqux4",
				"updated": "20230113095535"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这个例子是为了让你有更多的思考，并不推荐在日常工作中这么来表示单词的边界，因为 \\b 明显更简洁，也更容易阅读和书写。"
				}
			]
		},
		{
			"ID": "20230113095536-avsip25",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113095536-avsip25",
				"updated": "20230113095550"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "总结"
				}
			]
		},
		{
			"ID": "20230113095551-fuqju9i",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113095551-fuqju9i",
				"updated": "20230113095605"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "单词的边界是使用 \\b 来表示，这个比较简单。而多行模式下，每一行的开始和结束是使用 ^ 和 $ 符号。如果想匹配整个字符串的开始或结束，可以使用 \\A 和 \\z，它们不受匹配模式的影响。"
				}
			]
		},
		{
			"ID": "20230113095611-wv024oj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113095611-wv024oj",
				"updated": "20230113095618"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "们来做一个小练习吧。前面我们用正则分组引用来实现替换重复出现的单词，其实之前写的正则是不严谨的，在一些场景下，其实是不能正常工作的，你能使用今天学到的知识来完善一下它么？"
				}
			]
		},
		{
			"ID": "20230113095619-31qvnqu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113095619-31qvnqu",
				"updated": "20230113095624"
			},
			"Children": [
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "the little cat cat2 is in the hat hat2, we like it."
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				}
			]
		},
		{
			"ID": "20230113095625-bvnysno",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113095625-bvnysno",
				"updated": "20230113095632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "需要注意一下，文本中 cat 和 cat2，还有 hat 和 hat2 其实是不同的单词。你应该能想到在 \\w+ 左右加上单词边界 \\b 来解决这个问题。你可以试一下，真的能像期望的那样工作么？也就是说，在分组引用时，前面的断言还有效么？"
				}
			]
		},
		{
			"ID": "20230113095606-i76o7mw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113095606-i76o7mw",
				"updated": "20230113095610"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113095610-cpasms5.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113095647-9nsb53v",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230113095647-9nsb53v",
				"updated": "20230113100748"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "6、转义"
				}
			]
		},
		{
			"ID": "20230113095653-nyaezw4",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113095653-nyaezw4",
				"updated": "20230113095702"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "转义字符"
				}
			]
		},
		{
			"ID": "20230113095703-f0g9353",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113095703-f0g9353",
				"updated": "20230113095712"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "转义序列通常有两种功能。第一种功能是编码无法用字母表直接表示的特殊数据。第二种功能是用于表示无法直接键盘录入的字符（如回车符）"
				}
			]
		},
		{
			"ID": "20230113095713-6j7ky6l",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113095713-6j7ky6l",
				"updated": "20230113095810"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113095810-ah5215o.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113095812-amo7fqn",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113095812-amo7fqn",
				"updated": "20230113095846"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "字符串转义和正则转义"
				}
			]
		},
		{
			"ID": "20230113095848-r7arh91",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113095848-r7arh91",
				"updated": "20230113095922"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "正则中 \\d 代表的是单个数字，但如果我们想表示成 反斜杠和字母 d，这时候就需要进行转义，写成 "
				},
				{
					"Type": "NodeBackslash",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBackslashContent",
							"Data": "\\"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "d，这个就表示反斜杠后面紧跟着一个字母 d。"
				}
			]
		},
		{
			"ID": "20230113095923-05lctic",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113095923-05lctic",
				"updated": "20230113095938"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113095938-6eml9q8.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113095940-r11cnz9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113095940-r11cnz9",
				"updated": "20230113095948"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "刚刚的反斜杠和 d 是连续出现的两个字符，如果你想表示成反斜杠或 d，可以用管道符号或中括号来实现，比如 "
				},
				{
					"Type": "NodeBackslash",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBackslashContent",
							"Data": "|"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "d 或 [\\d]"
				}
			]
		},
		{
			"ID": "20230113095949-ydn8oku",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113095949-ydn8oku",
				"updated": "20230113095952"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113095952-dpnol1l.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113095953-21mj383",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113095953-21mj383",
				"updated": "20230113100002"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "需要注意的是，如果你想用代码来测试这个，在程序中表示普通字符串的时候，我们如果要表示反斜杠，通常需要写成两个反斜杠，因为只写一个会被理解成“转义符号”，而不是反斜杠本身。"
				}
			]
		},
		{
			"ID": "20230113100003-aaj3bub",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113100003-aaj3bub",
				"updated": "20230113100052"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如何在正则中正确表示“反斜杠”呢？答案是写四个反斜杠。"
				}
			]
		},
		{
			"ID": "20230113100053-zoy3aeu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113100053-zoy3aeu",
				"updated": "20230113100134"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在正则中正确表示“反斜杠”具体的过程是这样子：我们输入的字符串，四个反斜杠 "
				},
				{
					"Type": "NodeBackslash",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBackslashContent",
							"Data": "\\"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，经过第一步字符串转义，它代表的含义是两个反斜杠 \\；这两个反斜杠再经过第二步正则转义，它就可以代表单个反斜杠 \\了。"
				}
			]
		},
		{
			"ID": "20230113100134-tbfpu94",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113100134-tbfpu94",
				"updated": "20230113100138"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113100138-8vcnbk3.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113100138-hucvn2k",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113100138-hucvn2k",
				"updated": "20230113100214"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "正则中元字符的转义"
				}
			]
		},
		{
			"ID": "20230113100215-2znrplg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113100215-2znrplg",
				"updated": "20230113100221"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "前面的内容中，我们讲了很多元字符，相信你一定都还记得。如果现在我们要查找比如星号（*）、加号（+）、问号（?）本身，而不是元字符的功能，这时候就需要对其进行转义，直接在前面加上反斜杠就可以了。这个转义就比较简单了"
				}
			]
		},
		{
			"ID": "20230113100221-4xfxasy",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113100221-4xfxasy",
				"updated": "20230113100234"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "括号的转义"
				}
			]
		},
		{
			"ID": "20230113100236-i5nqqt0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113100236-i5nqqt0",
				"updated": "20230113100243"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在正则中方括号 [] 和 花括号 {} 只需转义开括号，但圆括号 () 两个都要转义。我在下面给了你一个比较详细的例子"
				}
			]
		},
		{
			"ID": "20230113100257-yiinjec",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113100257-yiinjec",
				"updated": "20230113100412"
			},
			"Children": [
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "'\\ ( \\ ) \\ [] \\ {}'"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				}
			]
		},
		{
			"ID": "20230113100244-5yksxfh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113100244-5yksxfh",
				"updated": "20230113100255"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在正则中，圆括号通常用于分组，或者将某个部分看成一个整体，如果只转义开括号或闭括号，正则会认为少了另外一半，所以会报错"
				}
			]
		},
		{
			"ID": "20230113100419-hri6n1x",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113100419-hri6n1x",
				"updated": "20230113100419"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "使用函数消除元字符特殊含义"
				}
			]
		},
		{
			"ID": "20230113100450-ec0octl",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113100450-ec0octl",
				"updated": "20230113100450"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们也可以使用编程语言自带的转义函数来实现转义"
				}
			]
		},
		{
			"ID": "20230113100421-5i3mjog",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113100421-5i3mjog",
				"updated": "20230113100432"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113100432-qsmsihq.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113100451-2fvn064",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113100451-2fvn064",
				"updated": "20230113100456"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "字符组中的转义"
				}
			]
		},
		{
			"ID": "20230113100458-olo1p4r",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113100458-olo1p4r",
				"updated": "20230113100506"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "讲完了元字符的转义，我们现在来看看字符组中的转义。书写正则的时候，在字符组中，如果有过多的转义会导致代码可读性差。在字符组里只有三种情况需要转义，下面我来给你讲讲具体是哪三种情况"
				}
			]
		},
		{
			"ID": "20230113100507-x804uud",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113100507-x804uud",
				"updated": "20230113100514"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1、脱字符在中括号中，且在第一个位置需要转义"
				}
			]
		},
		{
			"ID": "20230113100514-a4e4242",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113100514-a4e4242",
				"updated": "20230113100522"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2、中划线在中括号中，且不在首尾位置："
				}
			]
		},
		{
			"ID": "20230113100517-0hprtma",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113100517-0hprtma",
				"updated": "20230113100526"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3、右括号在中括号中，且不在首位"
				}
			]
		},
		{
			"ID": "20230113100619-2xlsict",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113100619-2xlsict",
				"updated": "20230113100628"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "一般来说如果我们要想将元字符（."
				},
				{
					"Type": "NodeEmphasis",
					"Data": "em",
					"Children": [
						{
							"Type": "NodeEmA6kOpenMarker",
							"Data": "*"
						},
						{
							"Type": "NodeText",
							"Data": "+?() 之类）表示成它字面上本来的意思，是需要对其进行转义的，但如果它们出现在字符组中括号里，可以不转义。这种情况，一般都是单个长度的元字符，比如点号（.）、星号（"
						},
						{
							"Type": "NodeEmA6kCloseMarker",
							"Data": "*"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "）、加号（+）、问号（?）、左右圆括号等。它们都不再具有特殊含义，而是代表字符本身。但如果在中括号中出现 \\d 或 \\w 等符号时，他们还是元字符本身的含义。"
				}
			]
		},
		{
			"ID": "20230113100645-il78xg2",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113100645-il78xg2",
				"updated": "20230113100645"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "总结"
				}
			]
		},
		{
			"ID": "20230113100647-obn7gxr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113100647-obn7gxr",
				"updated": "20230113100652"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113100652-xxpcqzg.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113100842-232s2nq",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230113100842-232s2nq",
				"updated": "20230113100842"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "7、正则有哪些常见的流派及其特性"
				}
			]
		},
		{
			"ID": "20230113100852-hn0vsaj",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113100852-hn0vsaj",
				"updated": "20230113100932"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "POSIX 流派"
				}
			]
		},
		{
			"ID": "20230113100934-b0ajkjl",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113100934-b0ajkjl",
				"updated": "20230113100944"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这里我们先简要介绍一下 POSIX 流派。POSIX 规范定义了正则表达式的两种标准"
				}
			]
		},
		{
			"ID": "20230113100945-25umkeq",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230113100945-25umkeq",
				"updated": "20230113100950"
			},
			"Children": [
				{
					"ID": "20230113100952-dc2u7jg",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230113100952-dc2u7jg",
						"updated": "20230113100952"
					},
					"Children": [
						{
							"ID": "20230113100952-q9sj0c7",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230113100952-q9sj0c7",
								"updated": "20230113100956"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "BRE 标准（Basic Regular Expression 基本正则表达式）；"
								}
							]
						}
					]
				},
				{
					"ID": "20230113100956-e0j51gi",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230113100956-e0j51gi"
					},
					"Children": [
						{
							"ID": "20230113100956-m1jj0dw",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230113100956-m1jj0dw",
								"updated": "20230113101001"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "ERE 标准（Extended Regular Expression 扩展正则表达式）"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230113101001-ukrd2tp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113101001-ukrd2tp",
				"updated": "20230113101006"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "BRE 标准 和 ERE 标准"
				}
			]
		},
		{
			"ID": "20230113101006-51q9mte",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113101006-51q9mte",
				"updated": "20230113101012"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "早期 BRE 与 ERE 标准的区别主要在于，BRE 标准不支持量词问号和加号，也不支持多选分支结构管道符。BRE 标准在使用花括号，圆括号时要转义才能表示特殊含义。BRE 标准用起来这么不爽，于是有了 ERE 标准，在使用花括号，圆括号时不需要转义了，还支持了问号、加号 和 多选分支。"
				}
			]
		},
		{
			"ID": "20230113101013-61910pi",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113101013-61910pi",
				"updated": "20230113101038"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "BRE 标准和 ERE 标准的详细区别，我给了你一个参考图，你可以看一下，浅黄色背景是 BRE 和 ERE 不同的地方，三处天蓝色字体是 GNU 扩展"
				}
			]
		},
		{
			"ID": "20230113101038-xn5bef4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113101038-xn5bef4",
				"updated": "20230113101043"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113101043-lv5lttb.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113101044-k464hs5",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113101044-k464hs5",
				"updated": "20230113101051"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "POSIX 字符组"
				}
			]
		},
		{
			"ID": "20230113101054-rcfrx0m",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113101054-rcfrx0m",
				"updated": "20230113101102"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "POSIX 流派还有一个特殊的地方，就是有自己的字符组，叫 POSIX 字符组。这个类似于我们之前学习的 \\d 表示数字，\\s 表示空白符等，POSIX 中也定义了一系列的字符组。具体的清单和解释如下所示"
				}
			]
		},
		{
			"ID": "20230113101103-z896prf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113101103-z896prf",
				"updated": "20230113101106"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113101106-0gt31qu.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113101106-5pjdox3",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113101106-5pjdox3",
				"updated": "20230113101118"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "PCRE 流派"
				}
			]
		},
		{
			"ID": "20230113101130-t13hqg2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113101130-t13hqg2",
				"updated": "20230113101424"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "目前大部分常用编程语言都是源于 PCRE 标准，这个流派显著特征是有\\d、\\w、\\s 这类字符组简记方式"
				}
			]
		},
		{
			"ID": "20230113101424-5jc05ev",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113101424-5jc05ev",
				"updated": "20230113101432"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "不过，虽然 PCRE 流派是从 Perl 语言中衍生出来的，但与 Perl 语言中的正则表达式在语法上还是有一些细微差异，比如 PHP 的 preg 正则表达式 (Perl Regular Expression) 与 Perl 正则表达式的差异"
				}
			]
		},
		{
			"ID": "20230113101433-sqjec32",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113101433-sqjec32",
				"updated": "20230113101437"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在 Linux 中使用正则"
				}
			]
		},
		{
			"ID": "20230113101440-qx9netk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113101440-qx9netk",
				"updated": "20230113101449"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在遵循 POSIX 规范的 UNIX/LINUX 系统上，按照 BRE 标准 实现的有 grep、sed 和 vi/vim 等，而按照 ERE 标准 实现的有 egrep、awk 等"
				}
			]
		},
		{
			"ID": "20230113101450-faog085",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113101450-faog085",
				"updated": "20230113101453"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113101453-sw9mon0.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113101454-xyzp376",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113101454-xyzp376",
				"updated": "20230113101523"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "总结"
				}
			]
		},
		{
			"ID": "20230113101524-hwhb679",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113101524-hwhb679",
				"updated": "20230113101524"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113101524-78u9nc5.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113102002-muqt4ti",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230113102002-muqt4ti",
				"updated": "20230113102024"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "8、在语言中使用正则"
				}
			]
		},
		{
			"ID": "20230113102024-n0qub80",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113102024-n0qub80",
				"updated": "20230113102035"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "校验文本内容"
				}
			]
		},
		{
			"ID": "20230113102050-7r5yxmd",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20230113102050-7r5yxmd",
				"updated": "20230113102103"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "python"
				}
			]
		},
		{
			"ID": "20230113102239-28szq1g",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230113102239-28szq1g",
				"updated": "20230113102324"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "cHl0aG9u"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "# 测试环境 Python3\n\u003e\u003e\u003e import re\n\u003e\u003e\u003e re.match(r'\\d{4}-\\d{2}-\\d{2}', '2020-06-01')\n\u003e\u003e\u003e reg = re.compile(r'\\A\\d{4}-\\d{2}-\\d{2}\\Z')  # 建议先编译，提高效率\n\u003e\u003e\u003e reg.search('2020-06-01') is not None\nTrue\n\u003e\u003e\u003e reg.match('2020-06-01') is not None  # 使用match时\\A可省略\nTrue\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230113102335-7z3dpq9",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20230113102335-7z3dpq9",
				"updated": "20230113102339"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "go"
				}
			]
		},
		{
			"ID": "20230113102340-yxwavwd",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230113102340-yxwavwd",
				"updated": "20230113102527"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Z28="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "package main\nimport (\n   \"fmt\"\n   \"regexp\"\n)\n\nfunc main() {\n   re := regexp.MustCompile(`\\A\\d{4}-\\d{2}-\\d{2}\\z`)\n   // 输出 true\n   fmt.Println(re.MatchString(\"2020-06-01\"))\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230113102357-4g7a8jh",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20230113102357-4g7a8jh",
				"updated": "20230113102403"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "JavaScript"
				}
			]
		},
		{
			"ID": "20230113102405-6ndx8ug",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230113102405-6ndx8ug",
				"updated": "20230113102524"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YXNjcmlwdA=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "// 方法1\n/^\\d{4}-\\d{2}-\\d{2}$/.test(\"2020-06-01\")  // true\n\n// 方法2\nvar regex = /^\\d{4}-\\d{2}-\\d{2}$/\n\"2020-06-01\".search(regex) == 0  // true\n\n// 方法3\nvar regex = new RegExp(/^\\d{4}-\\d{2}-\\d{2}$/)\nregex.test(\"2020-01-01\") // tru 方法 3 本质上和方法 1 是一样的，方法 1 写起来更简洁\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230113102417-x8jskuz",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230113102417-x8jskuz",
				"updated": "20230113102522"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nclass Main {\n  public static void main(String[] args) {\n    //方法1，可以不加 \\A 和 \\z\n    System.out.println(Pattern.matches(\"\\\\d{4}-\\\\d{2}-\\\\d{2}\", \"2020-06-01\")); // true\n\n    //方法2，可以不加 \\A 和 \\z\n    System.out.println(\"2020-06-01\".matches(\"\\\\d{4}-\\\\d{2}-\\\\d{2}\")); // true\n  \n    //方法3，必须加上 \\A 和 \\z\n    Pattern pattern = Pattern.compile(\"\\\\A\\\\d{4}-\\\\d{2}-\\\\d{2}\\\\z\");\n    System.out.println(pattern.matcher(\"2020-06-01\").find()); // true\n  }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230113102457-m0awyik",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113102457-m0awyik",
				"updated": "20230113102458"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113102458-675obst.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113102035-1l31jmw",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"fold": "1",
				"id": "20230113102035-1l31jmw",
				"updated": "20230113102045"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "提取文件内容"
				}
			]
		},
		{
			"ID": "20230113102048-58kijgd",
			"Type": "NodeParagraph",
			"Properties": {
				"fold": "1",
				"heading-fold": "1",
				"id": "20230113102048-58kijgd"
			}
		},
		{
			"ID": "20230113102459-xjq1to9",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20230113102459-xjq1to9",
				"updated": "20230113102506"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Python"
				}
			]
		},
		{
			"ID": "20230113102507-c68j0xl",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230113102507-c68j0xl",
				"updated": "20230113102518"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "cHl0aG9u"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "# 没有子组时\n\u003e\u003e\u003e import re\n\u003e\u003e\u003e reg = re.compile(r'\\d{4}-\\d{2}')\n\u003e\u003e\u003e reg.findall('2020-05 2020-06')\n['2020-05', '2020-06']\n\n# 有子组时\n\u003e\u003e\u003e reg = re.compile(r'(\\d{4})-(\\d{2})')\n\u003e\u003e\u003e reg.findall('2020-05 2020-06')\n[('2020', '05'), ('2020', '06')]\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230113102531-dmlnm57",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20230113102531-dmlnm57",
				"updated": "20230113102540"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "go"
				}
			]
		},
		{
			"ID": "20230113102542-xvpkk45",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230113102542-xvpkk45",
				"updated": "20230113102549"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Z28="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "package main\nimport (\n  \"fmt\"\n  \"regexp\"\n)\n\nfunc main() {\n  re := regexp.MustCompile(`\\d{4}-\\d{2}`)\n  \n  // 返回一个切片(可动态扩容的数组) [2020-06 2020-07]\n  fmt.Println(re.FindAllString(\"2020-06 2020-07\", -1)) \n  \n  // 捕获子组的查找示例\n  re2 := regexp.MustCompile(`(\\d{4})-(\\d{2})`)\n  // 返回结果和上面 Python 类似\n  for _, match := range re2.FindAllStringSubmatch(\"2020-06 2020-07\", -1) {\n     fmt.Println(\"date: \", match[0])\n     fmt.Println(\"year: \", match[1])\n     fmt.Println(\"month:\", match[2])\n  }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230113102553-jge0p0p",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230113102553-jge0p0p",
				"updated": "20230113102611"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YXNjcmlwdA=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "// 使用g模式，查找所有符合要求的内容\n\"2020-06 2020-07\".match(/\\d{4}-\\d{2}/g)\n// 输出：[\"2020-06\", \"2020-07\"]\n\n// 不使用g模式，找到第一个就会停下来\n\"2020-06 2020-07\".match(/\\d{4}-\\d{2}/)\n// 输出：[\"2020-06\", index: 0, input: \"2020-06 2020-07\", groups: undefined]\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230113102617-q0irce0",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230113102617-q0irce0",
				"updated": "20230113102624"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nclass Main {\n  public static void main(String[] args) {  \n    Pattern pattern = Pattern.compile(\"\\\\d{4}-\\\\d{2}\");\n    Matcher match = pattern.matcher(\"2020-06 2020-07\");\n    while (match.find()) {\n      System.out.println(match.group());  \n    }\n  }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230113102630-jogkq2u",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113102630-jogkq2u",
				"updated": "20230113102630"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113102630-o4za4bo.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113102637-xfy90s8",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113102637-xfy90s8",
				"updated": "20230113102640"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "替换文本"
				}
			]
		},
		{
			"ID": "20230113102643-gz4wn0d",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20230113102643-gz4wn0d",
				"updated": "20230113102648"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "python"
				}
			]
		},
		{
			"ID": "20230113102650-12rqg1z",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230113102650-12rqg1z",
				"updated": "20230113102702"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "cHl0aG9u"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\u003e\u003e\u003e import re\n\u003e\u003e\u003e reg = re.compile(r'(\\d{2})-(\\d{2})-(\\d{4})')\n\n\u003e\u003e\u003e reg.sub(r'\\3年\\1月\\2日', '02-20-2020 05-21-2020')\n'2020年02月20日 2020年05月21日'\n\n# 可以在替换中使用 \\g\u003c数字\u003e，如果分组多于10个时避免歧义\n\u003e\u003e\u003e reg.sub(r'\\g\u003c3\u003e年\\g\u003c1\u003e月\\g\u003c2\u003e日', '02-20-2020 05-21-2020')\n'2020年02月20日 2020年05月21日'\n\n# 返回替换次数\n\u003e\u003e\u003e reg.subn(r'\\3年\\1月\\2日', '02-20-2020 05-21-2020')\n('2020年02月20日 2020年05月21日', 2)\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230113102704-lqscml7",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20230113102704-lqscml7",
				"updated": "20230113102707"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "go"
				}
			]
		},
		{
			"ID": "20230113102708-908ycfd",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230113102708-908ycfd",
				"updated": "20230113102716"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Z28="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "package main\nimport (\n  \"fmt\"\n  \"regexp\"\n)\n\nfunc main() {\n  re := regexp.MustCompile(`(\\d{2})-(\\d{2})-(\\d{4})`)\n\n  // 示例一，返回 2020年02月20日 2020年05月21日\n  fmt.Println(re.ReplaceAllString(\"02-20-2020 05-21-2020\", \"${3}年${1}月${2}日\"))\n\n  // 示例二，返回空字符串，因为\"3年\"，\"1月\"，\"2日\" 这样的子组不存在\n  fmt.Println(re.ReplaceAllString(\"02-20-2020 05-21-2020\", \"$3年$1月$2日\"))\n  \n  // 示例三，返回 2020-02-20 2020-05-21\n  fmt.Println(re.ReplaceAllString(\"02-20-2020 05-21-2020\", \"$3-$1-$2\"))\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230113102718-2irigup",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20230113102718-2irigup",
				"updated": "20230113102724"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "JavaScript"
				}
			]
		},
		{
			"ID": "20230113102729-x58egrs",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230113102729-x58egrs",
				"updated": "20230113102743"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YXNjcmlwdA=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "// 使用g模式，替换所有的\n\"02-20-2020 05-21-2020\".replace(/(\\d{2})-(\\d{2})-(\\d{4})/g, \"$3年$1月$2日\")\n// 输出 \"2020年02月20日 2020年05月21日\"\n\n// 不使用 g 模式时，只替换一次\n\"02-20-2020 05-21-2020\".replace(/(\\d{2})-(\\d{2})-(\\d{4})/, \"$3年$1月$2日\")\n// 输出 \"2020年02月20日 05-21-2020\"\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230113102744-aeszcmh",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20230113102744-aeszcmh",
				"updated": "20230113102746"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "java"
				}
			]
		},
		{
			"ID": "20230113102747-lb1hidz",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230113102747-lb1hidz",
				"updated": "20230113102757"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nclass Main {\n  public static void main(String[] args) {\n    //方法1，输出 2020年02月20日 2020年05月21日\n    System.out.println(\"02-20-2020 05-21-2020\".replaceAll(\"(\\\\d{2})-(\\\\d{2})-(\\\\d{4})\", \"$3年$1月$2日\"));\n  \n    //方法2，输出 2020年02月20日 2020年05月21日\n    final Pattern pattern = Pattern.compile(\"(\\\\d{2})-(\\\\d{2})-(\\\\d{4})\");\n    Matcher match = pattern.matcher(\"02-20-2020 05-21-2020\");\n    System.out.println(match.replaceAll(\"$3年$1月$2日\"));\n  }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230113102802-mmcur0a",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113102802-mmcur0a",
				"updated": "20230113102802"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113102802-ekoqds7.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113102807-x2a9kto",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113102807-x2a9kto",
				"updated": "20230113102808"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "切割文本内容"
				}
			]
		},
		{
			"ID": "20230113102812-2apw97x",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20230113102812-2apw97x",
				"updated": "20230113102821"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Python"
				}
			]
		},
		{
			"ID": "20230113102823-c3wboq2",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230113102823-c3wboq2",
				"updated": "20230113102920"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "cHl0aG9u"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\u003e\u003e\u003e import re\n\u003e\u003e\u003e reg = re.compile(r'\\W+')\n\u003e\u003e\u003e reg.split(\"apple, pear! orange; tea\")\n['apple', 'pear', 'orange', 'tea']\n\n# 限制切割次数，比如切一刀，变成两部分\n\u003e\u003e\u003e reg.split(\"apple, pear! orange; tea\", 1)\n['apple', 'pear! orange; tea']\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230113102922-hik1uc9",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20230113102922-hik1uc9",
				"updated": "20230113102925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "go"
				}
			]
		},
		{
			"ID": "20230113102927-wka68v2",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230113102927-wka68v2",
				"updated": "20230113103009"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Z28="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "package main\nimport (\n  \"fmt\"\n  \"regexp\"\n)\n\nfunc main() {\n  re := regexp.MustCompile(`\\W+`)\n  \n  // 返回 []string{\"apple\", \"pear\", \"orange\", \"tea\"}\n  fmt.Printf(\"%#v\", re.Split(\"apple, pear! orange; tea\", -1)\n\n  // 返回 []string{\"apple\", \"pear! orange; tea\"}\n  fmt.Printf(\"%#v\\n\", re.Split(\"apple, pear! orange; tea\", 2))\n\n  // 返回 []string{\"apple\"}\n  fmt.Printf(\"%#v\\n\", re.Split(\"apple\", 2))\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230113102933-5xm8z7n",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20230113102933-5xm8z7n",
				"updated": "20230113103015"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "JavaScript"
				}
			]
		},
		{
			"ID": "20230113103017-wxidga3",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230113103017-wxidga3",
				"updated": "20230113103028"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YXNjcmlwdA=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\"apple, pear! orange; tea\".split(/\\W+/)\n// 输出：[\"apple\", \"pear\", \"orange\", \"tea\"]\n\n// 传入第二个参数的情况\n\"apple, pear! orange; tea\".split(/\\W+/, 1)\n// 输出 [\"apple\"]\n\"apple, pear! orange; tea\".split(/\\W+/, 2)\n// 输出 [\"apple\", \"pear\"]\n\"apple, pear! orange; tea\".split(/\\W+/, 10)\n// 输出 [\"apple\", \"pear\", \"orange\", \"tea\"]\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230113103029-2z88gl9",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20230113103029-2z88gl9",
				"updated": "20230113103034"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "java"
				}
			]
		},
		{
			"ID": "20230113103035-w8lpegi",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230113103035-w8lpegi",
				"updated": "20230113103101"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nclass Main {\n  public static void main(String[] args) {\n    Pattern pattern = Pattern.compile(\"\\\\W+\");\n    for(String s : pattern.split(\"apple, pear! orange; tea\")) {\n      System.out.println(s);\n    }\n\n    pattern.split(\"apple, pear! orange; tea\", 2)\n    // 返回 \"apple\" 和 \"pear! orange; tea\"\n  }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230113103107-y6fqcze",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113103107-y6fqcze",
				"updated": "20230113103107"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113103107-ysgdgca.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113103116-oqgingb",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113103116-oqgingb",
				"updated": "20230113103119"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "总结"
				}
			]
		},
		{
			"ID": "20230113103120-2expwbl",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113103120-2expwbl",
				"updated": "20230113103122"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113103122-1f3h8e8.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113103156-xmkctte",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230113103156-xmkctte",
				"updated": "20230113103543"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "9、问题集绵"
				}
			]
		},
		{
			"ID": "20230113103543-8xwswme",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113103543-8xwswme",
				"updated": "20230113103605"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在讲解具体的问题前，我先来说一下使用正则处理问题的基本思路。有一些方法比较固定，比如将问题分解成多个小问题，每个小问题见招拆招：某个位置上可能有多个字符的话，就⽤字符组。某个位置上有多个字符串的话，就⽤多选结构。出现的次数不确定的话，就⽤量词。对出现的位置有要求的话，就⽤锚点锁定位置。"
				}
			]
		},
		{
			"ID": "20230113103606-pkbu3dl",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113103606-pkbu3dl",
				"updated": "20230113103611"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在正则中比较难的是某些字符不能出现，这个情况又可以进一步分为组成中不能出现，和要查找的内容前后不能出现。后一种用环视来解决就可以了。我们主要说一下第一种。"
				}
			]
		},
		{
			"ID": "20230113103612-x35n1tb",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113103612-x35n1tb",
				"updated": "20230113103617"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果是要查找的内容中不能出现某些字符，这种情况比较简单，可以通过使用中括号来排除字符组，比如非元音字母可以使用 [^aeiou]来表示。"
				}
			]
		},
		{
			"ID": "20230113103617-4ze992u",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113103617-4ze992u",
				"updated": "20230113103628"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果是内容中不能出现某个子串，比如要求密码是 6 位，且不能有连续两个数字出现。假设密码允许的范围是 \\w，你应该可以想到使用 \\w{6} 来表示 6 位密码，但如果里面不能有连续两个数字的话，该如何限制呢？这个可以环视来解决，就是每个字符的后面都不能是两个数字（要注意开头也不能是 \\d\\d），下面是使用 Python3 语言测试的示例。"
				}
			]
		},
		{
			"ID": "20230113103628-j0cdi32",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230113103628-j0cdi32",
				"updated": "20230113103638"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "cHl0aG9u"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\u003e\u003e\u003e import re\n\u003e\u003e\u003e re.match(r'^((?!\\d\\d)\\w){6}$', '11abcd')  # 不能匹配上\n# 提示 (?!\\d\\d) 代表右边不能是两个数字，但它左边没有正则，即为空字符串\n\n\u003e\u003e\u003e re.match(r'^((?!\\d\\d)\\w){6}$', '1a2b3c')  # 能匹配上\n\u003cre.Match object; span=(0, 6), match='1a2b3c'\u003e\n\n\u003e\u003e\u003e re.match(r'^(\\w(?!\\d\\d)){6}$', '11abcd')  # 错误正则示范                                                              \n\u003cre.Match object; span=(0, 6), match='11abcd'\u003e\n\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230113103645-p0nhi7r",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113103645-p0nhi7r",
				"updated": "20230113103716"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1、匹配数字"
				}
			]
		},
		{
			"ID": "20230113103648-l06y43p",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113103648-l06y43p",
				"updated": "20230113103725"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "数字的匹配比较简单，通过我们学习的字符组，量词等就可以轻松解决"
				}
			]
		},
		{
			"ID": "20230113103733-xu07o1o",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230113103733-xu07o1o",
				"updated": "20230113103733"
			},
			"Children": [
				{
					"ID": "20230113103733-nwi3oyb",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230113103733-nwi3oyb",
						"updated": "20230113103733"
					},
					"Children": [
						{
							"ID": "20230113103733-akzjcz6",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230113103733-akzjcz6",
								"updated": "20230113103741"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "数字在正则中可以使用 \\d 或 [0-9] 来表示。"
								}
							]
						}
					]
				},
				{
					"ID": "20230113103741-mc7eyuy",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230113103741-mc7eyuy"
					},
					"Children": [
						{
							"ID": "20230113103741-i45g6ir",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230113103741-i45g6ir",
								"updated": "20230113103745"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果是连续的多个数字，可以使用 \\d+ 或 [0-9]+。"
								}
							]
						}
					]
				},
				{
					"ID": "20230113103746-ctl7wsm",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230113103746-ctl7wsm"
					},
					"Children": [
						{
							"ID": "20230113103746-1yupb13",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230113103746-1yupb13",
								"updated": "20230113103750"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果 n 位数据，可以使用 \\d{n}。"
								}
							]
						}
					]
				},
				{
					"ID": "20230113103750-gcpfs4w",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230113103750-gcpfs4w"
					},
					"Children": [
						{
							"ID": "20230113103750-pyel04z",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230113103750-pyel04z",
								"updated": "20230113103755"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果是至少 n 位数据，可以使用 \\d{n,}。"
								}
							]
						}
					]
				},
				{
					"ID": "20230113103756-pb2p7oh",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230113103756-pb2p7oh"
					},
					"Children": [
						{
							"ID": "20230113103756-cq9xvhp",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230113103756-cq9xvhp",
								"updated": "20230113103801"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果是 m-n 位数字，可以使用 \\d{m,n}。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230113103801-mvwz8ui",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"fold": "1",
				"id": "20230113103801-mvwz8ui",
				"updated": "20230113103817"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2、匹配正数、负数和小数"
				}
			]
		},
		{
			"ID": "20230113103819-6j807zm",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113103819-6j807zm",
				"updated": "20230113103824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果希望正则能匹配到比如 3，3.14，-3.3，+2.7 等数字，需要注意的是，开头的正负符号可能有，也可能没有，所以可以使用 [-+]? 来表示，小数点和后面的内容也不一定会有，所以可以使用 (?:"
				},
				{
					"Type": "NodeBackslash",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBackslashContent",
							"Data": "."
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "\\d+)? 来表示，因此匹配正数、负数和小数的正则可以写成 [-+]?\\d+(?:"
				},
				{
					"Type": "NodeBackslash",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBackslashContent",
							"Data": "."
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "\\d+)?。"
				}
			]
		},
		{
			"ID": "20230113103825-8ckntaj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113103825-8ckntaj",
				"updated": "20230113103828"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113103828-62gafeb.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113103828-m1otjqn",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113103828-m1otjqn",
				"updated": "20230113103833"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "非负整数，包含 0 和 正整数，可以表示成[1-9]\\d*|0。"
				}
			]
		},
		{
			"ID": "20230113103834-yp1rku7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113103834-yp1rku7",
				"updated": "20230113103838"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "非正整数，包含 0 和 负整数，可以表示成-[1-9]\\d*|0。"
				}
			]
		},
		{
			"ID": "20230113103839-xa0mzds",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113103839-xa0mzds",
				"updated": "20230113103846"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3、浮点数"
				}
			]
		},
		{
			"ID": "20230113103847-942fpw1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113103847-942fpw1",
				"updated": "20230113103853"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这个问题你可能觉得比较简单，其中表示正负的符号和小数点可能有，也可能没有，直接用  [-+]?\\d+(?:"
				},
				{
					"Type": "NodeBackslash",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBackslashContent",
							"Data": "."
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "\\d+)? 来表示"
				}
			]
		},
		{
			"ID": "20230113103853-j4etscj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113103853-j4etscj",
				"updated": "20230113103858"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果我们考虑 .5 和 +.5 这样的写法，但一般不会有 -.5 这样的写法。正则又如何写呢？"
				}
			]
		},
		{
			"ID": "20230113103859-f3qoqsi",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113103859-f3qoqsi",
				"updated": "20230113103902"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们可以把问题拆解，浮点数分为符号位、整数部分、小数点和小数部分，这些部分都有可能不存在，如果我们每个部分都加个问号，这样整个表达式可以匹配上空。"
				}
			]
		},
		{
			"ID": "20230113103903-36vxlpy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113103903-36vxlpy",
				"updated": "20230113103908"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "根据上面的提示，负号的时候整数部分不能没有，而正数的时候，整数部分可以没有，所以正则你可以将正负两种情况拆开，使用多选结构写成 -?\\d+(?:"
				},
				{
					"Type": "NodeBackslash",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBackslashContent",
							"Data": "."
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "\\d+)?|"
				},
				{
					"Type": "NodeBackslash",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBackslashContent",
							"Data": "+"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "?(?:\\d+(?:"
				},
				{
					"Type": "NodeBackslash",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBackslashContent",
							"Data": "."
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "\\d+)?|"
				},
				{
					"Type": "NodeBackslash",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBackslashContent",
							"Data": "."
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "\\d+)"
				}
			]
		},
		{
			"ID": "20230113103908-8mma85m",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113103908-8mma85m",
				"updated": "20230113103914"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这个可以拆分成两个问题"
				}
			]
		},
		{
			"ID": "20230113103914-yvbr72f",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113103914-yvbr72f",
				"updated": "20230113103920"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "负数浮点数表示：-\\d+(?:"
				},
				{
					"Type": "NodeBackslash",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBackslashContent",
							"Data": "."
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "\\d+)?"
				}
			]
		},
		{
			"ID": "20230113103921-gic071g",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113103921-gic071g",
				"updated": "20230113103926"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "正数浮点数表示："
				},
				{
					"Type": "NodeBackslash",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBackslashContent",
							"Data": "+"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "?(?:\\d+(?:"
				},
				{
					"Type": "NodeBackslash",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBackslashContent",
							"Data": "."
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "\\d+)?|"
				},
				{
					"Type": "NodeBackslash",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBackslashContent",
							"Data": "."
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "\\d+)"
				}
			]
		},
		{
			"ID": "20230113103927-gmb4wvy",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113103927-gmb4wvy",
				"updated": "20230113103936"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "4、十六进制数"
				}
			]
		},
		{
			"ID": "20230113103936-zveo9ph",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113103936-zveo9ph",
				"updated": "20230113103945"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "十六进制的数字除了有 0-9 之外，还会有 a-f（或 A-F） 代表 10 到 15 这 6 个数字，所以正则可以写成 [0-9A-Fa-f]+。"
				}
			]
		},
		{
			"ID": "20230113103945-fc05lid",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113103945-fc05lid",
				"updated": "20230113103954"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "5、手机号码"
				}
			]
		},
		{
			"ID": "20230113103954-3dv4fij",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113103954-3dv4fij",
				"updated": "20230113103959"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "手机号应该是比较常见的，手机号段比较复杂，如果要兼容所有的号段并不容易。目前来看，前四位是有一些限制，甚至 1740 和 1741 限制了前 5 位号段"
				}
			]
		},
		{
			"ID": "20230113104000-zh0avh1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113104000-zh0avh1",
				"updated": "20230113104004"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们可以简单地使用字符组和多选分支，来准确地匹配手机号段。如果只限制前 2 位，可以表示成 1[3-9]\\d{9}，如果想再精确些，限制到前三位，比如使用1(?:3\\d|4[5-9]|5[0-35-9]|6[2567]|7[0-8]|8\\d|9[1389])\\d{8}来表示。如果想精确到 4 位，甚至 5 位，可以根据公开的号段信息自己来写一下，但要注意的是，越是精确，只要有新的号段，你就得改这个正则，维护起来会比较麻烦。另外，在实际运用的时候，你可能还要考虑一下有一些号码了 +86 或 0086 之类的前缀的情况。"
				}
			]
		},
		{
			"ID": "20230113104004-se2qk44",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113104004-se2qk44",
				"updated": "20230113104012"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "手机号段的正则写起来其实写起来并不难，但麻烦的是后期的维护成本比较高，我之前就遇到过这种情况，买了一个 188 的移动号码，有不少系统在这个号段开放了挺长时间之后，还认为这个号段不合法"
				}
			]
		},
		{
			"ID": "20230113104012-e4hw6yd",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113104012-e4hw6yd",
				"updated": "20230113104030"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "6、身份证号码"
				}
			]
		},
		{
			"ID": "20230113104031-5eeoau6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113104031-5eeoau6",
				"updated": "20230113104038"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我国的身份证号码是分两代的，第一代是 15 位，第二代是 18 位。如果是 18 位，最后一位可以是 X（或 x），两代开头都不能是 0，根据规则，你应该能很容易写出相应的正则，第一代可以用 [1-9]\\d{14} 来表示，第二代比第一代多 3 位数据，可以使用量词 0 到 1 次，即写成"
				}
			]
		},
		{
			"ID": "20230113104038-0xyjb00",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113104038-0xyjb00",
				"updated": "20230113104045"
			},
			"Children": [
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "[1-9]\\d{14}(\\d\\d[0-9Xx])?"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				}
			]
		},
		{
			"ID": "20230113104046-3czzc4v",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113104046-3czzc4v",
				"updated": "20230113104056"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "7、邮政编码"
				}
			]
		},
		{
			"ID": "20230113104057-7neb7w1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113104057-7neb7w1",
				"updated": "20230113104104"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "邮编一般为 6 位数字，比较简单，可以写成 \\d{6}，之前我们也提到过，6 位数字在其它情况下出现可能性也非常大，比如手机号的一部分，身份证号的一部分，所以如果是数据提取，一般需要添加断言，即写成"
				}
			]
		},
		{
			"ID": "20230113104105-0r8mdz0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113104105-0r8mdz0",
				"updated": "20230113104113"
			},
			"Children": [
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "(?\u003c!\\d)\\d{6}(?!\\d)"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				}
			]
		},
		{
			"ID": "20230113104114-dzf170x",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113104114-dzf170x",
				"updated": "20230113104132"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "8、腾讯 QQ 号码"
				}
			]
		},
		{
			"ID": "20230113104133-5r7xzww",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113104133-5r7xzww",
				"updated": "20230113104139"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "前 QQ 号不能以 0 开头，最长的有 10 位，最短的从 10000（5 位）开始。从规则上我们可以得知，首位是 1-9，后面跟着是 4 到 9 位的数字，即可以使用"
				}
			]
		},
		{
			"ID": "20230113104140-vnpg2ep",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113104140-vnpg2ep",
				"updated": "20230113104148"
			},
			"Children": [
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "[1-9][0-9]{4,9}"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				}
			]
		},
		{
			"ID": "20230113104149-n620crw",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113104149-n620crw",
				"updated": "20230113104158"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "9、中文字符"
				}
			]
		},
		{
			"ID": "20230113104158-ppi9tkd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113104158-ppi9tkd",
				"updated": "20230113104203"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "中文属于多字节 Unicode 字符，之前我们讲过比如通过 Unicode 属性，但有一些语言是不支持这种属性的，可以通过另外一个办法，就是码值的范围，中文的范围是 4E00 - 9FFF 之间，这样可以覆盖日常使用大多数情况"
				}
			]
		},
		{
			"ID": "20230113104203-pi8be50",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113104203-pi8be50",
				"updated": "20230113104208"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "不同的语言是表示方式有一些差异，比如在 Python，Java，JavaScript 中，Unicode 可以写成 \\u码值 来表示，即匹配中文的正则可以写成 [\\u4E00-\\u9FFF]，如果在 PHP 中使用，Unicode 就需要写成 \\u{码值} 的样式。下面是在 Python3 语言中测试的示例，你可以参考一下"
				}
			]
		},
		{
			"ID": "20230113104209-2qq8ngd",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230113104209-2qq8ngd",
				"updated": "20230113104221"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "cHl0aG9u"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "# 测试环境，Python3\n\u003e\u003e\u003e import re\n\u003e\u003e\u003e reg = re.compile(r'[\\u4E00-\\u9FFF]')\n\u003e\u003e\u003e reg.findall(\"和伟忠一起学正则regex\")\n['和', '伟', '忠', '一', '起', '学', '正', '则']\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230113104223-mw7a8ba",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113104223-mw7a8ba",
				"updated": "20230113104233"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "10、IPv4 地址"
				}
			]
		},
		{
			"ID": "20230113104233-l1mcz3s",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113104233-l1mcz3s",
				"updated": "20230113104238"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "IPv4 地址通常表示成 27.86.1.226 的样式，4 个数字用点隔开，每一位范围是 0-255，比如从日志中提取出 IP，如果不要求那么精确，一般使用 \\d{1,3}("
				},
				{
					"Type": "NodeBackslash",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBackslashContent",
							"Data": "."
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "\\d{1,3}){3}就够了，需要注意点号需要转义"
				}
			]
		},
		{
			"ID": "20230113104238-hcwt2n2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113104238-hcwt2n2",
				"updated": "20230113104241"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20230113104241-359qdyc.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230113104242-wng03y0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113104242-wng03y0",
				"updated": "20230113104247"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果我们想更精确地匹配，可以针对一到三位数分别考虑，一位数时可以表示成 0{0,2}\\d，两位数时可以表示成 0?[1-9]\\d，三位数时可以表示成 1\\d\\d|2[0-4]\\d|25[0-5]，使用多选分支结构把他们写到一起，就是 0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]这样"
				}
			]
		},
		{
			"ID": "20230113104249-ndyetoq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113104249-ndyetoq",
				"updated": "20230113104253"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这是表示出了 IPv4 地址中的一位（正则假设是 X），我们可以把 IPv4 表示成 X.X.X.X，可以使用量词，写成 (?:X.){3}X 或 X(?:.X){3}，由于 X 本身比较复杂，里面有多选分支结构，所以需要把它加上括号，所以 IPv4 的正则应该可以写成"
				}
			]
		},
		{
			"ID": "20230113104339-cj7zfol",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113104339-cj7zfol",
				"updated": "20230113104851"
			},
			"Children": [
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "(?:1\\d\\d|2[0-4]\\d|25[0-5]|0?[1-9]\\d|0{0,2}\\d)(?:.(?:1\\d\\d|2[0-4]\\d|25[0-5]|0?[1-9]\\d|0{0,2}\\d)){3}"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				}
			]
		},
		{
			"ID": "20230113104748-0eomjpe",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113104748-0eomjpe",
				"updated": "20230113104909"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "11、日期和时间"
				}
			]
		},
		{
			"ID": "20230113104909-uredtgr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113104909-uredtgr",
				"updated": "20230113104916"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "假设日期格式是 yyyy-mm-dd，如果不那么严格，我们可以直接使用 \\d{4}-\\d{2}-\\d{2}。如果再精确一些，比如月份是 1-12，当为一位的时候，前面可能不带 0，可以写成 01 或 1，月份使用正则，可以表示成 1[0-2]|0?[1-9]，日可能是 1-31，可以表示成 [12]\\d|3[01]|0?[1-9]，这里需要注意的是 0?[1-9] 应该放在多选分支的最后面，因为放最前面，匹配上一位数字的时候就停止了（示例），正确的正则"
				}
			]
		},
		{
			"ID": "20230113104917-0xw24xl",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113104917-0xw24xl",
				"updated": "20230113104924"
			},
			"Children": [
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "应该是 \\d{4}-(?:1[0-2]|0?[1-9])-(?:[12]\\d|3[01]|0?[1-9])"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				}
			]
		},
		{
			"ID": "20230113104925-2pxwxve",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113104925-2pxwxve",
				"updated": "20230113104930"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "间格式比如是 23:34，如果是 24 小时制，小时是 0-23，分钟是 0-59，所以可以写成 (?:2[0-3]|1\\d|0?\\d):(?:[1-5]\\d|0?\\d)。12 小时制的也是类似的，你可以自己想一想怎么写。"
				}
			]
		},
		{
			"ID": "20230113104931-id3sezb",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113104931-id3sezb",
				"updated": "20230113104935"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "另外，日期中月份还有大小月的问题，比如 2 月闰年可以是 29 日，使用正则没法验证日期是不是正确的。我们也不应该使用正则来完成所有事情，而是只使用正则来限制具体的格式，比如四位数字，两位数字之类的，提取到之后，使用日期时间相关的函数进行转换，如果失败就证明不是合法的日期时间"
				}
			]
		},
		{
			"ID": "20230113104936-t158hwf",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113104936-t158hwf",
				"updated": "20230113104943"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "12、邮箱"
				}
			]
		},
		{
			"ID": "20230113104944-9r743xw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113104944-9r743xw",
				"updated": "20230113105100"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "邮箱的组成是比较复杂的，格式是 用户名 @主机名，用户名部分通常可以有英文字母，数字，下划线，点等组成，但其中点不能在开头，也不能重复出现。根据 RFC5322 没有办法写出一个完美的正则"
				}
			]
		},
		{
			"ID": "20230113105101-nga37l2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113105101-nga37l2",
				"updated": "20230113105108"
			},
			"Children": [
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "比如：[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+.[a-zA-Z0-9-.]+。"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				}
			]
		},
		{
			"ID": "20230113105109-bywti26",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230113105109-bywti26",
				"updated": "20230113105117"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "13、网页标签"
				}
			]
		},
		{
			"ID": "20230113105117-6j5xk8e",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113105117-6j5xk8e",
				"updated": "20230113105121"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "配对出现的标签，比如 title，一般网页标签不区分大小写，我们可以使用 (?i)\u003ctitle\u003e.*?\u003c/title\u003e来进行匹配。在提取引号里面的内容时，可以使用 ["
				},
				{
					"Type": "NodeSup",
					"Data": "sup",
					"Children": [
						{
							"Type": "NodeSupOpenMarker"
						},
						{
							"Type": "NodeText",
							"Data": "\"]+，方括号里面的内容时，可以使用 ["
						},
						{
							"Type": "NodeSupCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "\u003e]+ 等方式。"
				}
			]
		},
		{
			"ID": "20230113105122-rvwuz4n",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230113105122-rvwuz4n",
				"updated": "20230113105127"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们通过一些常见的问题，逐步进行分析，讲解了正则表达式书写时的思路，和一些常见的错误。这些正则如果用于校验，还需要添加断言，比如 \\A 和 \\z（或\\Z），或 ^ 和 $。如果用于数据提取，还应当在首尾添加相应的断言"
				}
			]
		}
	]
}