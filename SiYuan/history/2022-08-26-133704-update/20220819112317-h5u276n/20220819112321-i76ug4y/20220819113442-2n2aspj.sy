{
	"ID": "20220819113442-2n2aspj",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20220819113442-2n2aspj",
		"scroll": "{\u0026amp;quot;startId\u0026amp;quot;:\u0026amp;quot;20220826130632-oqzte2h\u0026amp;quot;,\u0026amp;quot;endId\u0026amp;quot;:\u0026amp;quot;20220826130632-49qizas\u0026amp;quot;,\u0026amp;quot;scrollTop\u0026amp;quot;:2300,\u0026amp;quot;focusId\u0026amp;quot;:\u0026amp;quot;20220826130632-ftonrki\u0026amp;quot;,\u0026amp;quot;focusStart\u0026amp;quot;:50,\u0026amp;quot;focusEnd\u0026amp;quot;:50}",
		"title": "Redis 数据结构",
		"updated": "20220826132243"
	},
	"Children": [
		{
			"ID": "20220826130632-oqzte2h",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20220826130632-oqzte2h",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "Redis 为什么那么快？"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-lpbwrqm",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-lpbwrqm",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "除了它是内存数据库，使得所有的操作都在内存上进行之外，还有一个重要因素，它实现的数据结构，使得我们对数据进行增删查改操作时，Redis 能高效的处理。"
				}
			]
		},
		{
			"ID": "20220826130632-4aj008x",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-4aj008x",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "因此，这次我们就来好好聊一下 Redis 数据结构，这个在面试中太常问了。"
				}
			]
		},
		{
			"ID": "20220826130632-c10yzkg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-c10yzkg",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "注意， "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "Redis 数据结构并不是指 String（字符串）对象、List（列表）对象、Hash（哈希）对象、Set（集合）对象和 Zset（有序集合）对象，因为这些是 Redis 键值对中值的数据类型，也就是数据的保存形式，这些对象的底层实现的方式就用到了数据结构"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 。"
				}
			]
		},
		{
			"ID": "20220826130632-8tcdxzl",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-8tcdxzl",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我画了一张 Redis 数据类型（也叫 Redis 对象）和底层数据结构的对应关图，左边是 Redis 3.0版本的，也就是《Redis 设计与实现》这本书讲解的版本，现在看还是有点过时了，右边是现在 Github 最新的 Redis 代码的（还未发布正式版本）。"
				}
			]
		},
		{
			"ID": "20220826130632-qy02xcs",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-qy02xcs",
				"updated": "20220826132234"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "1_46XLDI_@@HLPG7G38"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/1_46XLDI_@@HLPG7G38-20220826132234-ypfdshl.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "可以看到，Redis 数据类型的底层数据结构随着版本的更新也有所不同，比如："
				}
			]
		},
		{
			"ID": "20220826130632-avbyc5j",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220826130632-avbyc5j",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"ID": "20220826130632-8nvd3ce",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-8nvd3ce",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-w1dqzah",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-w1dqzah",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在 Redis 3.0 版本中 List 对象的底层数据结构由「双向链表」或「压缩表列表」实现，但是在 3.2 版本之后，List 数据类型底层数据结构是由 quicklist 实现的；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-vbabi0g",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-vbabi0g",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-qk0l0sv",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-qk0l0sv",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在最新的 Redis 代码（还未发布正式版本）中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-rsfzf15",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-rsfzf15",
				"updated": "20220826130944"
			},
			"Children": [
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "\t共有 9 种数据结构：SDS、双向链表、压缩列表、哈希表、跳表、整数集合、quicklist、listpack。"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-sain9aq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-sain9aq",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "不多 BB 了，直接发车！"
				}
			]
		},
		{
			"ID": "20220826130632-0np44fe",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-0np44fe",
				"updated": "20220826132243"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "RMIKR9P3MLG_PHQTTQEF"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/RMIKR9P3MLG_PHQTTQEF-20220826132243-gg1m1o4.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20220826133503-01fz25j",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20220826133503-01fz25j"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "键值对数据库是怎么实现的？"
				}
			]
		},
		{
			"ID": "20220826130632-0ubicsr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-0ubicsr",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在开始讲数据结构之前，先给介绍下 Redis 是怎样实现键值对（key-value）数据库的。"
				}
			]
		},
		{
			"ID": "20220826130632-tdlao8g",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-tdlao8g",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Redis 的键值对中的 key 就是字符串对象，而  "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "value 可以是字符串对象，也可以是集合数据类型的对象"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " ，比如 List 对象、Hash 对象、Set 对象和 Zset 对象。"
				}
			]
		},
		{
			"ID": "20220826130632-nh4h5v8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-nh4h5v8",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "举个例子，我这里列出几种 Redis 新增键值对的命令："
				}
			]
		},
		{
			"ID": "20220826130632-ftonrki",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220826130632-ftonrki",
				"updated": "20220826132039"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "cmVkaXM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\u003e SET name \"xiaolincoding\"\nOK\n\u003e HSET person name \"xiaolincoding\" age 18\n0\n\u003e RPUSH stu \"xiaolin\" \"xiaomei\"\n(integer) 4\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220826130632-0b035n2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-0b035n2",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这些命令代表着："
				}
			]
		},
		{
			"ID": "20220826130632-bpotvjd",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220826130632-bpotvjd",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"ID": "20220826130632-nbvrlr2",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-nbvrlr2",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-hmdb19p",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-hmdb19p",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "第一条命令：name 是一个 "
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "字符串键"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ，因为键的 "
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "值是一个字符串对象"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-zc30ara",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-zc30ara",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-dxmgjyc",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-dxmgjyc",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "第二条命令：person 是一个 "
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "哈希表键"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ，因为键的 "
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "值是一个包含两个键值对的哈希表对象"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-y7kagk9",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-y7kagk9",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-lf4u1h8",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-lf4u1h8",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "第三条命令：stu 是一个 "
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "列表键"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ，因为键的 "
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "值是一个包含两个元素的列表对象"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ；"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-8nnnyly",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-8nnnyly",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这些键值对是如何保存在 Redis 中的呢？"
				}
			]
		},
		{
			"ID": "20220826130632-oi0vwsk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-oi0vwsk",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Redis 是使用了一个「哈希表」保存所有键值对，哈希表的最大好处就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对。哈希表其实就是一个数组，数组中的元素叫做哈希桶。"
				}
			]
		},
		{
			"ID": "20220826130632-4iumrl0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-4iumrl0",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Redis 的哈希桶是怎么保存键值对数据的呢？"
				}
			]
		},
		{
			"ID": "20220826130632-lrvhrr2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-lrvhrr2",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "哈希桶存放的是指向键值对数据的指针（dictEntry*），这样通过指针就能找到键值对数据，然后因为键值对的值可以保存字符串对象和集合数据类型的对象，所以键值对的数据结构中并不是直接保存值本身，而是保存了 void * key 和 void * value 指针，分别指向了实际的键对象和值对象，这样一来，即使值是集合数据，也可以通过 void * value 指针找到。"
				}
			]
		},
		{
			"ID": "20220826130632-vufp8ay",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-vufp8ay",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我这里画了一张 Redis 保存键值对所涉及到的数据结构。"
				}
			]
		},
		{
			"ID": "20220826132144-uhttwxl",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826132144-uhttwxl",
				"updated": "20220826132145"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "1661491301216"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/1661491301216-20220826132145-s84lfzm.jpg"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20220826130632-ix57vsr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-ix57vsr",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这些数据结构的内部细节，我先不展开讲，后面在讲哈希表数据结构的时候，在详细的说说，因为用到的数据结构是一样的。这里先大概说下图中涉及到的数据结构的名字和用途："
				}
			]
		},
		{
			"ID": "20220826130632-49qizas",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220826130632-49qizas",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"ID": "20220826130632-5cjxnhp",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-5cjxnhp",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-78jj89m",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-78jj89m",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "redisDb 结构，表示 Redis 数据库的结构，结构体里存放了指向了 dict 结构的指针；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-selglvn",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-selglvn",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-qvt9omc",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-qvt9omc",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "dict 结构，结构体里存放了 2 个哈希表，正常情况下都是用「哈希表1」，「哈希表2」只有在 rehash 的时候才用，具体什么是 rehash，我在本文的哈希表数据结构会讲；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-v09cauk",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-v09cauk",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-srftcqa",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-srftcqa",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "ditctht 结构，表示哈希表的结构，结构里存放了哈希表数组，数组中的每个元素都是指向一个哈希表节点结构（dictEntry）的指针；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-9qs8lvw",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-9qs8lvw",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-7y8dodv",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-7y8dodv",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "dictEntry 结构，表示哈希表节点的结构，结构里存放了  **void * key 和 void * value 指针， "
								},
								{
									"Type": "NodeEmphasis",
									"Data": "em",
									"Children": [
										{
											"Type": "NodeEmA6kOpenMarker",
											"Data": "*"
										},
										{
											"Type": "NodeText",
											"Data": "key 指向的是 String 对象，而 "
										},
										{
											"Type": "NodeEmphasis",
											"Data": "em",
											"Children": [
												{
													"Type": "NodeEmA6kOpenMarker",
													"Data": "*"
												},
												{
													"Type": "NodeText",
													"Data": "value 则可以指向 String 对象，也可以指向集合类型的对象，比如 List 对象、Hash 对象、Set 对象和 Zset 对象"
												},
												{
													"Type": "NodeEmA6kCloseMarker",
													"Data": "*"
												}
											]
										},
										{
											"Type": "NodeEmA6kCloseMarker",
											"Data": "*"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " 。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-gneyb3q",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-gneyb3q",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "特别说明下，void * key 和 void * value 指针指向的是  "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "Redis 对象"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " ，Redis 中的每个对象都由 redisObject 结构表示，如下图："
				}
			]
		},
		{
			"ID": "20220826130632-p98lewv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-p98lewv",
				"updated": "20220826132259"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "4WQDMBRECER15V0AFKW686"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/4WQDMBRECER15V0AFKW686-20220826132259-fdsf7o7.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				}
			]
		},
		{
			"ID": "20220826132300-pgf8i1x",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826132300-pgf8i1x"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "对象结构里包含的成员变量："
				}
			]
		},
		{
			"ID": "20220826130632-c89719e",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220826130632-c89719e",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"ID": "20220826130632-moc5y76",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-moc5y76",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-qw8luby",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-qw8luby",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "type，标识该对象是什么类型的对象（String 对象、 List 对象、Hash 对象、Set 对象和 Zset 对象）；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-2p4urm2",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-2p4urm2",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-d3rr8ez",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-d3rr8ez",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "encoding，标识该对象使用了哪种底层的数据结构；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-30fey02",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-30fey02",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-5lmjpqi",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-5lmjpqi",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "ptr，指向底层数据结构的指针"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " 。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-0tw2wdd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-0tw2wdd",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我画了一张 Redis 键值对数据库的全景图，你就能清晰知道 Redis 对象和数据结构的关系了："
				}
			]
		},
		{
			"ID": "20220826130632-l8bk4z7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-l8bk4z7",
				"updated": "20220826132309"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "1661491387691"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/1661491387691-20220826132309-evgw6y0.jpg"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "接下里，就好好聊一下底层数据结构！"
				}
			]
		},
		{
			"ID": "20220826130632-ebzv1xx",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20220826130632-ebzv1xx",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "SDS"
				}
			]
		},
		{
			"ID": "20220826130632-mmk557b",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-mmk557b",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "字符串在 Redis 中是很常用的，键值对中的键是字符串类型，值有时也是字符串类型。"
				}
			]
		},
		{
			"ID": "20220826130632-dir6gye",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-dir6gye",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Redis 是用 C 语言实现的，但是它没有直接使用 C 语言的 char* 字符数组来实现字符串，而是自己封装了一个名为简单动态字符串（simple dynamic string，SDS） 的数据结构来表示字符串，也就是 Redis 的 String 数据类型的底层数据结构是 SDS。"
				}
			]
		},
		{
			"ID": "20220826130632-3p3okim",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-3p3okim",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "既然 Redis 设计了 SDS 结构来表示字符串，肯定是 C 语言的 char* 字符数组存在一些缺陷。"
				}
			]
		},
		{
			"ID": "20220826130632-9tb8k4d",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-9tb8k4d",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "要了解这一点，得先来看看 char* 字符数组的结构。"
				}
			]
		},
		{
			"ID": "20220826130632-yjndady",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220826130632-yjndady",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "C 语言字符串的缺陷"
				}
			]
		},
		{
			"ID": "20220826130632-5rdm75u",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-5rdm75u",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "C 语言的字符串其实就是一个字符数组，即数组中每个元素是字符串中的一个字符。"
				}
			]
		},
		{
			"ID": "20220826130632-7xbxf4i",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-7xbxf4i",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "比如，下图就是字符串“xiaolin”的 char* 字符数组的结构："
				}
			]
		},
		{
			"ID": "20220826130632-8v7ymii",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-8v7ymii",
				"updated": "20220826132317"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "1661491395546"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/1661491395546-20220826132317-63kon3k.jpg"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				}
			]
		},
		{
			"ID": "20220826132318-m45lomj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826132318-m45lomj"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "没学过 C 语言的同学，可能会好奇为什么最后一个字符是“\\0”？"
				}
			]
		},
		{
			"ID": "20220826130632-9n75asz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-9n75asz",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在 C 语言里，对字符串操作时，char * 指针只是指向字符数组的起始位置，而 "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "字符数组的结尾位置就用“\\0”表示，意思是指字符串的结束"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 。"
				}
			]
		},
		{
			"ID": "20220826130632-5n1uz0g",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-5n1uz0g",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "因此，C 语言标准库中的字符串操作函数就通过判断字符是不是 “\\0” 来决定要不要停止操作，如果当前字符不是 “\\0” ，说明字符串还没结束，可以继续操作，如果当前字符是 “\\0” 是则说明字符串结束了，就要停止操作。"
				}
			]
		},
		{
			"ID": "20220826130632-cv232s6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-cv232s6",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "举个例子，C 语言获取字符串长度的函数 "
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "strlen"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，就是通过字符数组中的每一个字符，并进行计数，等遇到字符为 “\\0” 后，就会停止遍历，然后返回已经统计到的字符个数，即为字符串长度。下图显示了 strlen 函数的执行流程："
				}
			]
		},
		{
			"ID": "20220826130632-oniqc2e",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-oniqc2e",
				"updated": "20220826132326"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "1661491404065"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/1661491404065-20220826132325-wggot7z.jpg"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				}
			]
		},
		{
			"ID": "20220826132326-5xydxid",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826132326-5xydxid"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "很明显， "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "C 语言获取字符串长度的时间复杂度是 O（N）（"
						},
						{
							"Type": "NodeEmphasis",
							"Data": "em",
							"Children": [
								{
									"Type": "NodeEmA6kOpenMarker",
									"Data": "*"
								},
								{
									"Type": "NodeText",
									"Data": "这是一个可以改进的地方"
								},
								{
									"Type": "NodeEmA6kCloseMarker",
									"Data": "*"
								}
							]
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " ）"
				}
			]
		},
		{
			"ID": "20220826130632-788jw5n",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-788jw5n",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "C 语言字符串用 “\\0” 字符作为结尾标记有个缺陷。假设有个字符串中有个 “\\0” 字符，这时在操作这个字符串时就会 "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "提早结束"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " ，比如 “xiao\\0lin” 字符串，计算字符串长度的时候则会是 4，如下图："
				}
			]
		},
		{
			"ID": "20220826130632-vu0mpf5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-vu0mpf5",
				"updated": "20220826132333"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "1661491411655"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/1661491411655-20220826132333-vj8ota3.jpg"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				}
			]
		},
		{
			"ID": "20220826132333-ee75srg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826132333-ee75srg"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "因此，除了字符串的末尾之外， "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "字符串里面不能含有 “\\0” 字符"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " ，否则最先被程序读入的 “\\0” 字符将被误认为是字符串结尾，这个限制使得 C 语言的字符串只能保存文本数据，"
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "不能保存像图片、音频、视频文化这样的二进制数据（ "
						},
						{
							"Type": "NodeEmphasis",
							"Data": "em",
							"Children": [
								{
									"Type": "NodeEmA6kOpenMarker",
									"Data": "*"
								},
								{
									"Type": "NodeText",
									"Data": "这也是一个可以改进的地方"
								},
								{
									"Type": "NodeEmA6kCloseMarker",
									"Data": "*"
								}
							]
						},
						{
							"Type": "NodeText",
							"Data": " ）"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-edtsdpt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-edtsdpt",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "另外， C 语言标准库中字符串的操作函数是很不安全的，对程序员很不友好，稍微一不注意，就会导致缓冲区溢出。"
				}
			]
		},
		{
			"ID": "20220826130632-h0afn8r",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-h0afn8r",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "举个例子，strcat 函数是可以将两个字符串拼接在一起。"
				}
			]
		},
		{
			"ID": "20220826130632-nsx60j6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-nsx60j6",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "c //将 src 字符串拼接到 dest 字符串后面 char *strcat(char *dest, const char* src);"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-i4fml55",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-i4fml55",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "C 语言的字符串是不会记录自身的缓冲区大小的"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " ，所以 strcat 函数假定程序员在执行这个函数时，已经为 dest 分配了足够多的内存，可以容纳 src 字符串中的所有内容，而 "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "一旦这个假定不成立，就会发生缓冲区溢出将可能会造成程序运行终止，（"
						},
						{
							"Type": "NodeEmphasis",
							"Data": "em",
							"Children": [
								{
									"Type": "NodeEmA6kOpenMarker",
									"Data": "*"
								},
								{
									"Type": "NodeText",
									"Data": "这是一个可以改进的地方"
								},
								{
									"Type": "NodeEmA6kCloseMarker",
									"Data": "*"
								}
							]
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " ）。"
				}
			]
		},
		{
			"ID": "20220826130632-fm77bw1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-fm77bw1",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "而且，strcat 函数和 strlen 函数类似，时间复杂度也很高，也都需要先通过遍历字符串才能得到目标字符串的末尾。然后对于 strcat 函数来说，还要再遍历源字符串才能完成追加， "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "对字符串的操作效率不高"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 。"
				}
			]
		},
		{
			"ID": "20220826130632-39yormu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-39yormu",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "好了， 通过以上的分析，我们可以得知 C 语言的字符串不足之处以及可以改进的地方："
				}
			]
		},
		{
			"ID": "20220826130632-07krx8o",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220826130632-07krx8o",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"ID": "20220826130632-ccas83s",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-ccas83s",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-vvq8h8o",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-vvq8h8o",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "获取字符串长度的时间复杂度为 O（N）；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-eluecjo",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-eluecjo",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-w0qdhkq",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-w0qdhkq",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "字符串的结尾是以 “\\0” 字符标识，字符串里面不能包含有 “\\0” 字符，因此不能保存二进制数据；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-b8jqpia",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-b8jqpia",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-jgsvoiy",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-jgsvoiy",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "字符串操作函数不高效且不安全，比如有缓冲区溢出的风险，有可能会造成程序运行终止；"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-gutd3bq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-gutd3bq",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Redis 实现的 SDS 的结构就把上面这些问题解决了，接下来我们一起看看 Redis 是如何解决的。"
				}
			]
		},
		{
			"ID": "20220826130632-m5fnhaa",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220826130632-m5fnhaa",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "SDS 结构设计"
				}
			]
		},
		{
			"ID": "20220826130632-pe89y1o",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-pe89y1o",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "下图就是 Redis 5.0 的 SDS 的数据结构："
				}
			]
		},
		{
			"ID": "20220826130632-7p35hd7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-7p35hd7",
				"updated": "20220826132342"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "1661491420070"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/1661491420070-20220826132342-d2clolo.jpg"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				}
			]
		},
		{
			"ID": "20220826132342-ipqjdje",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826132342-ipqjdje"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "结构中的每个成员变量分别介绍下："
				}
			]
		},
		{
			"ID": "20220826130632-hjajtzc",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220826130632-hjajtzc",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"ID": "20220826130632-zy07txe",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-zy07txe",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-dtw0wip",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-dtw0wip",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "len，记录了字符串长度"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " 。这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要 O（1）。"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-j0mv9im",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-j0mv9im",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-d8g3i6y",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-d8g3i6y",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "alloc，分配给字符数组的空间长度"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " 。这样在修改字符串的时候，可以通过 "
								},
								{
									"Type": "NodeCodeSpan",
									"Data": "code",
									"Children": [
										{
											"Type": "NodeCodeSpanOpenMarker"
										},
										{
											"Type": "NodeCodeSpanContent",
											"Data": "alloc - len"
										},
										{
											"Type": "NodeCodeSpanCloseMarker"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " 计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出的问题。"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-avmr1ig",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-avmr1ig",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-cqc8jj8",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-cqc8jj8",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "flags，用来表示不同类型的 SDS"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " 。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，后面在说明区别之处。"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-zwrz1yb",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-zwrz1yb",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-5zxq932",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-5zxq932",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "buf[]，字符数组，用来保存实际数据"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " 。不仅可以保存字符串，也可以保存二进制数据。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-rid3t7b",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-rid3t7b",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "总的来说，Redis 的 SDS 结构在原本字符数组之上，增加了三个元数据：len、alloc、flags，用来解决 C 语言字符串的缺陷。"
				}
			]
		},
		{
			"ID": "20220826130632-298pdwc",
			"Type": "NodeHeading",
			"HeadingLevel": 5,
			"Properties": {
				"id": "20220826130632-298pdwc",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "O（1）复杂度获取字符串长度"
				}
			]
		},
		{
			"ID": "20220826130632-wgd41dn",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-wgd41dn",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "C 语言的字符串长度获取 strlen 函数，需要通过遍历的方式来统计字符串长度，时间复杂度是 O（N）。"
				}
			]
		},
		{
			"ID": "20220826130632-ef1i3p4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-ef1i3p4",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "而 Redis 的 SDS 结构因为加入了 len 成员变量，那么 "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "获取字符串长度的时候，直接返回这个成员变量的值就行，所以复杂度只有 O（1）"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 。"
				}
			]
		},
		{
			"ID": "20220826130632-ude9fi7",
			"Type": "NodeHeading",
			"HeadingLevel": 5,
			"Properties": {
				"id": "20220826130632-ude9fi7",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "二进制安全"
				}
			]
		},
		{
			"ID": "20220826130632-lm3j24f",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-lm3j24f",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "因为 SDS 不需要用 “\\0” 字符来标识字符串结尾了，而是 "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "有个专门的 len 成员变量来记录长度，所以可存储包含 “\\0” 的数据"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 。但是 SDS 为了兼容部分 C 语言标准库的函数， SDS 字符串结尾还是会加上 “\\0” 字符。"
				}
			]
		},
		{
			"ID": "20220826130632-by38xce",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-by38xce",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "因此， SDS 的 API 都是以处理二进制的方式来处理 SDS 存放在 buf[] 里的数据，程序不会对其中的数据做任何限制，数据写入的时候时什么样的，它被读取时就是什么样的。"
				}
			]
		},
		{
			"ID": "20220826130632-kmieeim",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-kmieeim",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "通过使用二进制安全的 SDS，而不是 C 字符串，使得 Redis 不仅可以保存文本数据，也可以保存任意格式的二进制数据。"
				}
			]
		},
		{
			"ID": "20220826130632-axjiand",
			"Type": "NodeHeading",
			"HeadingLevel": 5,
			"Properties": {
				"id": "20220826130632-axjiand",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "不会发生缓冲区溢出"
				}
			]
		},
		{
			"ID": "20220826130632-d1zyq95",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-d1zyq95",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "C 语言的字符串标准库提供的字符串操作函数，大多数（比如 strcat 追加字符串函数）都是不安全的，因为这些函数把缓冲区大小是否满足操作需求的工作交由开发者来保证，程序内部并不会判断缓冲区大小是否足够用，当发生了缓冲区溢出就有可能造成程序异常结束。"
				}
			]
		},
		{
			"ID": "20220826130632-em9bg1k",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-em9bg1k",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "所以，Redis 的 SDS 结构里引入了 alloc 和 len 成员变量，这样 SDS API 通过 "
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "alloc - len"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 计算，可以算出剩余可用的空间大小，这样在对字符串做修改操作的时候，就可以由程序内部判断缓冲区大小是否足够用。"
				}
			]
		},
		{
			"ID": "20220826130632-xppmoeu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-xppmoeu",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "而且， "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "当判断出缓冲区大小不够用时，Redis 会自动将扩大 SDS 的空间大小（小于 1MB 翻倍扩容，大于 1MB 按 1MB 扩容）"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " ，以满足修改所需的大小。"
				}
			]
		},
		{
			"ID": "20220826130632-tvlotiy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-tvlotiy",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在扩展 SDS 空间之前，SDS API 会优先检查未使用空间是否足够，如果不够的话，API 不仅会为 SDS 分配修改所必须要的空间，还会给 SDS 分配额外的「未使用空间」。"
				}
			]
		},
		{
			"ID": "20220826130632-eusrate",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-eusrate",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这样的好处是，下次在操作 SDS 时，如果 SDS 空间够的话，API 就会直接使用「未使用空间」，而无须执行内存分配， "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "有效的减少内存分配次数"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 。"
				}
			]
		},
		{
			"ID": "20220826130632-bpp12n0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-bpp12n0",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "所以，使用 SDS 即不需要手动修改 SDS 的空间大小，也不会出现缓冲区溢出的问题。"
				}
			]
		},
		{
			"ID": "20220826130632-vd8933o",
			"Type": "NodeHeading",
			"HeadingLevel": 5,
			"Properties": {
				"id": "20220826130632-vd8933o",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "节省内存空间"
				}
			]
		},
		{
			"ID": "20220826130632-3j7u975",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-3j7u975",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "SDS 结构中有个 flags 成员变量，表示的是 SDS 类型。"
				}
			]
		},
		{
			"ID": "20220826130632-r7lg3i2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-r7lg3i2",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Redos 一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64。"
				}
			]
		},
		{
			"ID": "20220826130632-dhcme58",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-dhcme58",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这 5 种类型的主要 "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "区别就在于，它们数据结构中的 len 和 alloc 成员变量的数据类型不同"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 。"
				}
			]
		},
		{
			"ID": "20220826130632-cjixehx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-cjixehx",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "比如 sdshdr16 和 sdshdr32 这两个类型，它们的定义分别如下："
				}
			]
		},
		{
			"ID": "20220826130632-xujt053",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220826130632-xujt053",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Yw=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "struct __attribute__ ((__packed__)) sdshdr16 {\n    uint16_t len;\n    uint16_t alloc; \n    unsigned char flags; \n    char buf[];\n};\n\n\nstruct __attribute__ ((__packed__)) sdshdr32 {\n    uint32_t len;\n    uint32_t alloc; \n    unsigned char flags;\n    char buf[];\n};\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220826130632-ns1d8q9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-ns1d8q9",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "可以看到："
				}
			]
		},
		{
			"ID": "20220826130632-8i2xcim",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220826130632-8i2xcim",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"ID": "20220826130632-oom4etw",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-oom4etw",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-7ie2hby",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-7ie2hby",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "sdshdr16 类型的 len 和 alloc 的数据类型都是 uint16_t，表示字符数组长度和分配空间大小不能超过 2 的 16 次方。"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-gbgbhu2",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-gbgbhu2",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-bwisv2l",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-bwisv2l",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "sdshdr32 则都是 uint32_t，表示表示字符数组长度和分配空间大小不能超过 2 的 32 次方。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-kh1m8md",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-kh1m8md",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "之所以 SDS 设计不同类型的结构体，是为了能灵活保存不同大小的字符串，从而有效节省内存空间"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 。比如，在保存小字符串时，结构头占用空间也比较少。"
				}
			]
		},
		{
			"ID": "20220826130632-rny6j2w",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-rny6j2w",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "除了设计不同类型的结构体，Redis 在编程上还 "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "使用了专门的编译优化来节省内存空间"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " ，即在 struct 声明了 "
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "__attribute__ ((packed))"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " ，它的作用是： "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "告诉编译器取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对齐"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 。"
				}
			]
		},
		{
			"ID": "20220826130632-632uvu7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-632uvu7",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "比如，sdshdr16 类型的 SDS，默认情况下，编译器会按照 16 字节对齐的方式给变量分配内存，这意味着，即使一个变量的大小不到 16 个字节，编译器也会给它分配 16 个字节。"
				}
			]
		},
		{
			"ID": "20220826130632-ren46rs",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-ren46rs",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "举个例子，假设下面这个结构体，它有两个成员变量，类型分别是 char 和 int，如下所示："
				}
			]
		},
		{
			"ID": "20220826130632-p9nphjd",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220826130632-p9nphjd",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Yw=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#include \u003cstdio.h\u003e\n\n struct test1 {\n    char a;\n    int b;\n } test1;\n\nint main() {\n     printf(\"%lu\\n\", sizeof(test1));\n     return 0;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220826130632-buu27ii",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-buu27ii",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "大家猜猜这个结构体大小是多少？我先直接说答案，这个结构体大小计算出来是 8。"
				}
			]
		},
		{
			"ID": "20220826130632-q67mdtd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-q67mdtd",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "这是因为默认情况下，编译器是使用「字节对齐」的方式分配内存，虽然 char 类型只占一个字节，但是由于成员变量里有 int 类型，它占用了 4 个字节，所以在成员变量为 char 类型分配内存时，会分配 4 个字节，其中这多余的 3 个字节是为了字节对齐而分配的，相当于有 3 个字节被浪费掉了。"
				}
			]
		},
		{
			"ID": "20220826130632-20xe0ca",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-20xe0ca",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果不想编译器使用字节对齐的方式进行分配内存，可以采用了 "
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "__attribute__ ((packed))"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 属性定义结构体，这样一来，结构体实际占用多少内存空间，编译器就分配多少空间。"
				}
			]
		},
		{
			"ID": "20220826130632-1aasfc1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-1aasfc1",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "比如，我用 "
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "__attribute__ ((packed))"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 属性定义下面的结构体 ，同样包含 char 和 int 两个类型的成员变量，代码如下所示："
				}
			]
		},
		{
			"ID": "20220826130632-uxfvyek",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220826130632-uxfvyek",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Yw=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#include \u003cstdio.h\u003e\n\nstruct __attribute__((packed)) test2  {\n    char a;\n    int b;\n } test2;\n\nint main() {\n     printf(\"%lu\\n\", sizeof(test2));\n     return 0;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220826130632-4fyjmtx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-4fyjmtx",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这时打印的结果是 5（1 个字节 char + 4 字节 int）。"
				}
			]
		},
		{
			"ID": "20220826130632-d0du8xw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-d0du8xw",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AE%9E%E9%99%85%E5%AF%B9%E9%BD%90.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "可以看得出，这是按照实际占用字节数进行分配内存的，这样可以节省内存空间。"
				}
			]
		},
		{
			"ID": "20220826130632-yx95rkt",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20220826130632-yx95rkt",
				"updated": "20220826130632"
			}
		},
		{
			"ID": "20220826130632-buw6erp",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20220826130632-buw6erp",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "链表"
				}
			]
		},
		{
			"ID": "20220826130632-mwf1b1r",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-mwf1b1r",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "大家最熟悉的数据结构除了数组之外，我相信就是链表了。"
				}
			]
		},
		{
			"ID": "20220826130632-ixdpwta",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-ixdpwta",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Redis 的 List 对象的底层实现之一就是链表。C 语言本身没有链表这个数据结构的，所以 Redis 自己设计了一个链表数据结构。"
				}
			]
		},
		{
			"ID": "20220826130632-6pskd9o",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220826130632-6pskd9o",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "链表节点结构设计"
				}
			]
		},
		{
			"ID": "20220826130632-yuwbl7m",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-yuwbl7m",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "先来看看「链表节点」结构的样子："
				}
			]
		},
		{
			"ID": "20220826130632-gwx6vwc",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220826130632-gwx6vwc",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Yw=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "typedef struct listNode {\n    //前置节点\n    struct listNode *prev;\n    //后置节点\n    struct listNode *next;\n    //节点的值\n    void *value;\n} listNode;\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220826130632-z6h24bs",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-z6h24bs",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "有前置节点和后置节点，可以看的出，这个是一个双向链表。"
				}
			]
		},
		{
			"ID": "20220826130632-f2k1tre",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-f2k1tre",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "#### 链表结构设计"
				}
			]
		},
		{
			"ID": "20220826130632-ie3h0kk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-ie3h0kk",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "不过，Redis 在 listNode 结构体基础上又封装了 list 这个数据结构，这样操作起来会更方便，链表结构如下："
				}
			]
		},
		{
			"ID": "20220826130632-9arye4z",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220826130632-9arye4z",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Yw=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "typedef struct list {\n    //链表头节点\n    listNode *head;\n    //链表尾节点\n    listNode *tail;\n    //节点值复制函数\n    void *(*dup)(void *ptr);\n    //节点值释放函数\n    void (*free)(void *ptr);\n    //节点值比较函数\n    int (*match)(void *ptr, void *key);\n    //链表节点数量\n    unsigned long len;\n} list;\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220826130632-cd00usy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-cd00usy",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "list 结构为链表提供了链表头指针 head、链表尾节点 tail、链表节点数量 len、以及可以自定义实现的 dup、free、match 函数。"
				}
			]
		},
		{
			"ID": "20220826130632-vjnvmwb",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-vjnvmwb",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "举个例子，下面是由 list 结构和 3 个 listNode 结构组成的链表。"
				}
			]
		},
		{
			"ID": "20220826130632-pe43c5d",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-pe43c5d",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/list.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "#### 链表的优势与缺陷"
				}
			]
		},
		{
			"ID": "20220826130632-vnn8xad",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-vnn8xad",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Redis 的链表实现优点如下："
				}
			]
		},
		{
			"ID": "20220826130632-fl2g7ef",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220826130632-fl2g7ef",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"ID": "20220826130632-j2t5yma",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-j2t5yma",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-hbgp5zs",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-hbgp5zs",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "listNode 链表节点的结构里带有 prev 和 next 指针， "
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "获取某个节点的前置节点或后置节点的时间复杂度只需O(1)，而且这两个指针都可以指向 NULL，所以链表是无环链表"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-n8bxoqx",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-n8bxoqx",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-59k7kmw",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-59k7kmw",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "list 结构因为提供了表头指针 head 和表尾节点 tail，所以 "
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "获取链表的表头节点和表尾节点的时间复杂度只需O(1)"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-8urvrv8",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-8urvrv8",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-1fujt0l",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-1fujt0l",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "list 结构因为提供了链表节点数量 len，所以 "
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "获取链表中的节点数量的时间复杂度只需O(1)"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-6aiy2lq",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-6aiy2lq",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-1lwpwi2",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-1lwpwi2",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "listNode 链表节使用 void* 指针保存节点值，并且可以通过 list 结构的 dup、free、match 函数指针为节点设置该节点类型特定的函数，因此 "
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "链表节点可以保存各种不同类型的值"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ；"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-vfngyai",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-vfngyai",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "链表的缺陷也是有的："
				}
			]
		},
		{
			"ID": "20220826130632-62i03dv",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220826130632-62i03dv",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"ID": "20220826130632-k6gczu2",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-k6gczu2",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-hnwo02r",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-hnwo02r",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "链表每个节点之间的内存都是不连续的，意味着 "
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "无法很好利用 CPU 缓存"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " 。能很好利用 CPU 缓存的数据结构就是数组，因为数组的内存是连续的，这样就可以充分利用 CPU 缓存来加速访问。"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-k3j075u",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-k3j075u",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-5fm7xpa",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-5fm7xpa",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "还有一点，保存一个链表节点的值都需要一个链表节点结构头的分配， "
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "内存开销较大"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " 。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-m6u51if",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-m6u51if",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "因此，Redis 3.0 的 List 对象在数据量比较少的情况下，会采用「压缩列表」作为底层数据结构的实现，它的优势是节省内存空间，并且是内存紧凑型的数据结构。"
				}
			]
		},
		{
			"ID": "20220826130632-4tul7nc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-4tul7nc",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "不过，压缩列表存在性能问题（具体什么问题，下面会说），所以 Redis 在 3.2 版本设计了新的数据结构 quicklist，并将 List 对象的底层数据结构改由 quicklist 实现。"
				}
			]
		},
		{
			"ID": "20220826130632-2x7j15m",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-2x7j15m",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "然后在 Redis 5.0 设计了新的数据结构 listpack，沿用了压缩列表紧凑型的内存布局，最终在最新的 Redis 版本，将 Hash 对象和 Zset 对象的底层数据结构实现之一的压缩列表，替换成由 listpack 实现。"
				}
			]
		},
		{
			"ID": "20220826130632-tba5k1r",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20220826130632-tba5k1r",
				"updated": "20220826130632"
			}
		},
		{
			"ID": "20220826130632-f4gzofa",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20220826130632-f4gzofa",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "压缩列表"
				}
			]
		},
		{
			"ID": "20220826130632-4coppvs",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-4coppvs",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "压缩列表的最大特点，就是它被设计成一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销。"
				}
			]
		},
		{
			"ID": "20220826130632-h6j9ibc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-h6j9ibc",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "但是，压缩列表的缺陷也是有的："
				}
			]
		},
		{
			"ID": "20220826130632-9s7416j",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220826130632-9s7416j",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"ID": "20220826130632-hn4a48h",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-hn4a48h",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-rz805c1",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-rz805c1",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "不能保存过多的元素，否则查询效率就会降低；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-o0jdfy8",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-o0jdfy8",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-d2ecph8",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-d2ecph8",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-8tp9whm",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-8tp9whm",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "因此，Redis 对象（List 对象、Hash 对象、Zset 对象）包含的元素数量较少，或者元素值不大的情况才会使用压缩列表作为底层数据结构。"
				}
			]
		},
		{
			"ID": "20220826130632-fnrunm0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-fnrunm0",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "接下来，就跟大家详细聊下压缩列表。"
				}
			]
		},
		{
			"ID": "20220826130632-jcwoy4x",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220826130632-jcwoy4x",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "压缩列表结构设计"
				}
			]
		},
		{
			"ID": "20220826130632-udmy1fz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-udmy1fz",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "压缩列表是 Redis 为了节约内存而开发的，它是 "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "由连续内存块组成的顺序型数据结构"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " ，有点类似于数组。"
				}
			]
		},
		{
			"ID": "20220826130632-uy18n03",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-uy18n03",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%BB%93%E6%9E%84.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "压缩列表在表头有三个字段："
				}
			]
		},
		{
			"ID": "20220826130632-ugxv8tf",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220826130632-ugxv8tf",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"ID": "20220826130632-12c1wdp",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-12c1wdp",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-9wae2ya",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-9wae2ya",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeEmphasis",
									"Data": "em",
									"Children": [
										{
											"Type": "NodeEmA6kOpenMarker",
											"Data": "*"
										},
										{
											"Type": "NodeStrong",
											"Data": "strong",
											"Children": [
												{
													"Type": "NodeStrongA6kOpenMarker",
													"Data": "**"
												},
												{
													"Type": "NodeText",
													"Data": "zlbytes"
												},
												{
													"Type": "NodeStrongA6kCloseMarker",
													"Data": "**"
												}
											]
										},
										{
											"Type": "NodeEmA6kCloseMarker",
											"Data": "*"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ，记录整个压缩列表占用对内存字节数；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-hu7kxv7",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-hu7kxv7",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-lz937em",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-lz937em",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeEmphasis",
									"Data": "em",
									"Children": [
										{
											"Type": "NodeEmA6kOpenMarker",
											"Data": "*"
										},
										{
											"Type": "NodeStrong",
											"Data": "strong",
											"Children": [
												{
													"Type": "NodeStrongA6kOpenMarker",
													"Data": "**"
												},
												{
													"Type": "NodeText",
													"Data": "zltail"
												},
												{
													"Type": "NodeStrongA6kCloseMarker",
													"Data": "**"
												}
											]
										},
										{
											"Type": "NodeEmA6kCloseMarker",
											"Data": "*"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-klt2pni",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-klt2pni",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-obl6w9u",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-obl6w9u",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeEmphasis",
									"Data": "em",
									"Children": [
										{
											"Type": "NodeEmA6kOpenMarker",
											"Data": "*"
										},
										{
											"Type": "NodeStrong",
											"Data": "strong",
											"Children": [
												{
													"Type": "NodeStrongA6kOpenMarker",
													"Data": "**"
												},
												{
													"Type": "NodeText",
													"Data": "zllen"
												},
												{
													"Type": "NodeStrongA6kCloseMarker",
													"Data": "**"
												}
											]
										},
										{
											"Type": "NodeEmA6kCloseMarker",
											"Data": "*"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ，记录压缩列表包含的节点数量；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-l1pxgbz",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-l1pxgbz",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-k5gb8n4",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-k5gb8n4",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeEmphasis",
									"Data": "em",
									"Children": [
										{
											"Type": "NodeEmA6kOpenMarker",
											"Data": "*"
										},
										{
											"Type": "NodeStrong",
											"Data": "strong",
											"Children": [
												{
													"Type": "NodeStrongA6kOpenMarker",
													"Data": "**"
												},
												{
													"Type": "NodeText",
													"Data": "zlend"
												},
												{
													"Type": "NodeStrongA6kCloseMarker",
													"Data": "**"
												}
											]
										},
										{
											"Type": "NodeEmA6kCloseMarker",
											"Data": "*"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ，标记压缩列表的结束点，固定值 0xFF（十进制255）。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-8p3fjeb",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-8p3fjeb",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而 "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了，因此压缩列表不适合保存过多的元素"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 。"
				}
			]
		},
		{
			"ID": "20220826130632-xmgwyzw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-xmgwyzw",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "另外，压缩列表节点（entry）的构成如下："
				}
			]
		},
		{
			"ID": "20220826130632-1xjbkv6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-1xjbkv6",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%8A%82%E7%82%B9%E7%BB%93%E6%9E%84.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "压缩列表节点包含三部分内容："
				}
			]
		},
		{
			"ID": "20220826130632-2vsdhau",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220826130632-2vsdhau",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"ID": "20220826130632-tkxig1q",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-tkxig1q",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-1scqyfq",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-1scqyfq",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeEmphasis",
									"Data": "em",
									"Children": [
										{
											"Type": "NodeEmA6kOpenMarker",
											"Data": "*"
										},
										{
											"Type": "NodeStrong",
											"Data": "strong",
											"Children": [
												{
													"Type": "NodeStrongA6kOpenMarker",
													"Data": "**"
												},
												{
													"Type": "NodeText",
													"Data": "prevlen"
												},
												{
													"Type": "NodeStrongA6kCloseMarker",
													"Data": "**"
												}
											]
										},
										{
											"Type": "NodeEmA6kCloseMarker",
											"Data": "*"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ，记录了「前一个节点」的长度；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-gpukpjr",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-gpukpjr",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-dr77n28",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-dr77n28",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeEmphasis",
									"Data": "em",
									"Children": [
										{
											"Type": "NodeEmA6kOpenMarker",
											"Data": "*"
										},
										{
											"Type": "NodeStrong",
											"Data": "strong",
											"Children": [
												{
													"Type": "NodeStrongA6kOpenMarker",
													"Data": "**"
												},
												{
													"Type": "NodeText",
													"Data": "encoding"
												},
												{
													"Type": "NodeStrongA6kCloseMarker",
													"Data": "**"
												}
											]
										},
										{
											"Type": "NodeEmA6kCloseMarker",
											"Data": "*"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ，记录了当前节点实际数据的类型以及长度；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-fwpq00b",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-fwpq00b",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-wmjdcle",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-wmjdcle",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeEmphasis",
									"Data": "em",
									"Children": [
										{
											"Type": "NodeEmA6kOpenMarker",
											"Data": "*"
										},
										{
											"Type": "NodeStrong",
											"Data": "strong",
											"Children": [
												{
													"Type": "NodeStrongA6kOpenMarker",
													"Data": "**"
												},
												{
													"Type": "NodeText",
													"Data": "data"
												},
												{
													"Type": "NodeStrongA6kCloseMarker",
													"Data": "**"
												}
											]
										},
										{
											"Type": "NodeEmA6kCloseMarker",
											"Data": "*"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ，记录了当前节点的实际数据；"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-9zrh4zh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-9zrh4zh",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "当我们往压缩列表中插入数据时，压缩列表就会根据数据是字符串还是整数，以及数据的大小，会使用不同空间大小的 prevlen 和 encoding 这两个元素里保存的信息， "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "这种根据数据大小和类型进行不同的空间大小分配的设计思想，正是 Redis 为了节省内存而采用的"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 。"
				}
			]
		},
		{
			"ID": "20220826130632-99bmpqz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-99bmpqz",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "分别说下，prevlen 和 encoding 是如何根据数据的大小和类型来进行不同的空间大小分配。"
				}
			]
		},
		{
			"ID": "20220826130632-3cxo7bw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-3cxo7bw",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "压缩列表里的每个节点中的 prevlen 属性都记录了「前一个节点的长度」，而且 prevlen 属性的空间大小跟前一个节点长度值有关，比如："
				}
			]
		},
		{
			"ID": "20220826130632-k085l58",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220826130632-k085l58",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"ID": "20220826130632-4pl363d",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-4pl363d",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-q0pjqhw",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-q0pjqhw",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果 "
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "前一个节点的长度小于 254 字节"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ，那么 prevlen 属性需要用 "
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "1 字节的空间"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "来保存这个长度值；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-7911ogz",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-7911ogz",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-yn7qpxp",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-yn7qpxp",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果 "
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "前一个节点的长度大于等于 254 字节"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ，那么 prevlen 属性需要用 "
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "5 字节的空间"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "来保存这个长度值；"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-9ker5h8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-9ker5h8",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "encoding 属性的空间大小跟数据是字符串还是整数，以及字符串的长度有关："
				}
			]
		},
		{
			"ID": "20220826130632-bacjz1a",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220826130632-bacjz1a",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"ID": "20220826130632-bm4y3uh",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-bm4y3uh",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-kkkvaeu",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-kkkvaeu",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果 "
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "当前节点的数据是整数"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ，则 encoding 会使用 "
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "1 字节的空间"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "进行编码。"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-2la8gnx",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-2la8gnx",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-mk58egb",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-mk58egb",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果 "
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "当前节点的数据是字符串，根据字符串的长度大小"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ，encoding 会使用 "
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "1 字节/2字节/5字节的空间"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "进行编码。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-w0q9l2c",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220826130632-w0q9l2c",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "连锁更新"
				}
			]
		},
		{
			"ID": "20220826130632-ga6w2tb",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-ga6w2tb",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "压缩列表除了查找复杂度高的问题，还有一个问题。"
				}
			]
		},
		{
			"ID": "20220826130632-k3v5ljv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-k3v5ljv",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "压缩列表新增某个元素或修改某个元素时，如果空间不不够，压缩列表占用的内存空间就需要重新分配。而当新插入的元素较大时，可能会导致后续元素的 prevlen 占用空间都发生变化，从而引起「连锁更新」问题，导致每个元素的空间都要重新分配，造成访问压缩列表性能的下降"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 。"
				}
			]
		},
		{
			"ID": "20220826130632-jl3fd9v",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-jl3fd9v",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "前面提到，压缩列表节点的 prevlen 属性会根据前一个节点的长度进行不同的空间大小分配："
				}
			]
		},
		{
			"ID": "20220826130632-hdhsfew",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220826130632-hdhsfew",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"ID": "20220826130632-gntoia2",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-gntoia2",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-rbpivyo",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-rbpivyo",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果前一个 "
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "节点的长度小于 254 字节"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ，那么 prevlen 属性需要用 "
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "1 字节的空间"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "来保存这个长度值；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-qzzh1li",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-qzzh1li",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-qqaowji",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-qqaowji",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果前一个 "
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "节点的长度大于等于 254 字节"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ，那么 prevlen 属性需要用 "
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "5 字节的空间"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "来保存这个长度值；"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-n490nyh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-n490nyh",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "现在假设一个压缩列表中有多个连续的、长度在 250～253 之间的节点，如下图："
				}
			]
		},
		{
			"ID": "20220826130632-quowlzc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-quowlzc",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E4%BE%8B%E5%AD%90.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "因为这些节点长度值小于 254 字节，所以 prevlen 属性需要用 1 字节的空间来保存这个长度值。"
				}
			]
		},
		{
			"ID": "20220826130632-yrxga02",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-yrxga02",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这时，如果将一个长度大于等于 254 字节的新节点加入到压缩列表的表头节点，即新节点将成为 e1 的前置节点，如下图："
				}
			]
		},
		{
			"ID": "20220826130632-z3mhlqa",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-z3mhlqa",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B01.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "因为 e1 节点的 prevlen 属性只有 1 个字节大小，无法保存新节点的长度，此时就需要对压缩列表的空间重分配操作，并将 e1 节点的 prevlen 属性从原来的 1 字节大小扩展为 5 字节大小。"
				}
			]
		},
		{
			"ID": "20220826130632-l6wk2eg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-l6wk2eg",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "多米诺牌的效应就此开始。"
				}
			]
		},
		{
			"ID": "20220826130632-tlwr1i9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-tlwr1i9",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B02.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "e1 原本的长度在 250～253 之间，因为刚才的扩展空间，此时 e1 的长度就大于等于 254 了，因此原本 e2 保存 e1 的 prevlen 属性也必须从 1 字节扩展至 5 字节大小。"
				}
			]
		},
		{
			"ID": "20220826130632-n5dnfxn",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-n5dnfxn",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "正如扩展 e1 引发了对 e2 扩展一样，扩展 e2 也会引发对 e3 的扩展，而扩展 e3 又会引发对 e4 的扩展…. 一直持续到结尾。"
				}
			]
		},
		{
			"ID": "20220826130632-q4a021r",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-q4a021r",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "这种在特殊情况下产生的连续多次空间扩展操作就叫做「连锁更新」"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " ，就像多米诺牌的效应一样，第一张牌倒下了，推动了第二张牌倒下；第二张牌倒下，又推动了第三张牌倒下….，"
				}
			]
		},
		{
			"ID": "20220826130632-i9w63rs",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220826130632-i9w63rs",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "压缩列表的缺陷"
				}
			]
		},
		{
			"ID": "20220826130632-nynt1h7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-nynt1h7",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "空间扩展操作也就是重新分配内存，因此 "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "连锁更新一旦发生，就会导致压缩列表占用的内存空间要多次重新分配，这就会直接影响到压缩列表的访问性能"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 。"
				}
			]
		},
		{
			"ID": "20220826130632-8btc6pf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-8btc6pf",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "所以说， "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "虽然压缩列表紧凑型的内存布局能节省内存开销，但是如果保存的元素数量增加了，或是元素变大了，会导致内存重新分配，最糟糕的是会有「连锁更新」的问题"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 。"
				}
			]
		},
		{
			"ID": "20220826130632-3by45ga",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-3by45ga",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "因此， "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "压缩列表只会用于保存的节点数量不多的场景"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " ，只要节点数量足够小，即使发生连锁更新，也是能接受的。"
				}
			]
		},
		{
			"ID": "20220826130632-6r6rfay",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-6r6rfay",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "虽说如此，Redis 针对压缩列表在设计上的不足，在后来的版本中，新增设计了两种数据结构：quicklist（Redis 3.2 引入） 和 listpack（Redis 5.0 引入）。这两种数据结构的设计目标，就是尽可能地保持压缩列表节省内存的优势，同时解决压缩列表的「连锁更新」的问题。"
				}
			]
		},
		{
			"ID": "20220826130632-13450il",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20220826130632-13450il",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "哈希表"
				}
			]
		},
		{
			"ID": "20220826130632-8and8e4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-8and8e4",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "哈希表是一种保存键值对（key-value）的数据结构。"
				}
			]
		},
		{
			"ID": "20220826130632-8o9xazy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-8o9xazy",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "哈希表中的每一个 key 都是独一无二的，程序可以根据 key 查找到与之关联的 value，或者通过 key 来更新 value，又或者根据 key 来删除整个 key-value等等。"
				}
			]
		},
		{
			"ID": "20220826130632-3n40p9h",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-3n40p9h",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在讲压缩列表的时候，提到过 Redis 的 Hash 对象的底层实现之一是压缩列表（最新 Redis 代码已将压缩列表替换成 listpack）。Hash 对象的另外一个底层实现就是哈希表。"
				}
			]
		},
		{
			"ID": "20220826130632-qnwaoyd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-qnwaoyd",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "哈希表优点在于，它 "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "能以 O(1) 的复杂度快速查询数据"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 。怎么做到的呢？将 key 通过 Hash 函数的计算，就能定位数据在表中的位置，因为哈希表实际上是数组，所以可以通过索引值快速查询到数据。"
				}
			]
		},
		{
			"ID": "20220826130632-lf7hjex",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-lf7hjex",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "但是存在的风险也是有，在哈希表大小固定的情况下，随着数据不断增多，那么"
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "哈希冲突"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "的可能性也会越高。"
				}
			]
		},
		{
			"ID": "20220826130632-1nugxwr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-1nugxwr",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "解决哈希冲突的方式，有很多种。"
				}
			]
		},
		{
			"ID": "20220826130632-fnbp2ua",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-fnbp2ua",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "Redis 采用了「链式哈希」来解决哈希冲突"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " ，在不扩容哈希表的前提下，将具有相同哈希值的数据串起来，形成链接起，以便这些数据在表中仍然可以被查询到。"
				}
			]
		},
		{
			"ID": "20220826130632-1e14ta1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-1e14ta1",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "接下来，详细说说哈希表。"
				}
			]
		},
		{
			"ID": "20220826130632-svd1lcd",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220826130632-svd1lcd",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "哈希表结构设计"
				}
			]
		},
		{
			"ID": "20220826130632-rkvm3ej",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-rkvm3ej",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Redis 的哈希表结构如下："
				}
			]
		},
		{
			"ID": "20220826130632-pd91zhz",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220826130632-pd91zhz",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Yw=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "typedef struct dictht {\n    //哈希表数组\n    dictEntry **table;\n    //哈希表大小\n    unsigned long size;  \n    //哈希表大小掩码，用于计算索引值\n    unsigned long sizemask;\n    //该哈希表已有的节点数量\n    unsigned long used;\n} dictht;\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220826130632-nxu7ov4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-nxu7ov4",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "可以看到，哈希表是一个数组（dictEntry **table），数组的每个元素是一个指向「哈希表节点（dictEntry）」的指针。"
				}
			]
		},
		{
			"ID": "20220826130632-ytjk93p",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-ytjk93p",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%BB%93%E6%9E%84.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "哈希表节点的结构如下："
				}
			]
		},
		{
			"ID": "20220826130632-pvq8a69",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220826130632-pvq8a69",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Yw=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "typedef struct dictEntry {\n    //键值对中的键\n    void *key;\n\n    //键值对中的值\n    union {\n        void *val;\n        uint64_t u64;\n        int64_t s64;\n        double d;\n    } v;\n    //指向下一个哈希表节点，形成链表\n    struct dictEntry *next;\n} dictEntry;\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220826130632-j75iwwp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-j75iwwp",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "dictEntry 结构里不仅包含指向键和值的指针，还包含了指向下一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对链接起来，以此来解决哈希冲突的问题，这就是链式哈希。"
				}
			]
		},
		{
			"ID": "20220826130632-8yxeokt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-8yxeokt",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "另外，这里还跟你提一下，dictEntry 结构里键值对中的值是一个「联合体 v」定义的，因此，键值对中的值可以是一个指向实际值的指针，或者是一个无符号的 64 位整数或有符号的 64 位整数或double 类的值。这么做的好处是可以节省内存空间，因为当「值」是整数或浮点数时，就可以将值的数据内嵌在 dictEntry 结构里，无需再用一个指针指向实际的值，从而节省了内存空间。"
				}
			]
		},
		{
			"ID": "20220826130632-ar5ezfk",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220826130632-ar5ezfk",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "哈希冲突"
				}
			]
		},
		{
			"ID": "20220826130632-06xvvcw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-06xvvcw",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "哈希表实际上是一个数组，数组里多每一个元素就是一个哈希桶。"
				}
			]
		},
		{
			"ID": "20220826130632-6tt5536",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-6tt5536",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "当一个键值对的键经过 Hash 函数计算后得到哈希值，再将(哈希值 % 哈希表大小)取模计算，得到的结果值就是该 key-value 对应的数组元素位置，也就是第几个哈希桶。"
				}
			]
		},
		{
			"ID": "20220826130632-a99d5zn",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20220826130632-a99d5zn",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20220826130632-dq89q7x",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20220826130632-dq89q7x",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "什么是哈希冲突呢？"
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-6gy5v4b",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-6gy5v4b",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "举个例子，有一个可以存放 8 个哈希桶的哈希表。key1 经过哈希函数计算后，再将「哈希值 % 8 」进行取模计算，结果值为 1，那么就对应哈希桶 1，类似的，key9 和 key10 分别对应哈希桶 1 和桶 6。"
				}
			]
		},
		{
			"ID": "20220826130632-rqs5i52",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-rqs5i52",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "此时，key1 和 key9 对应到了相同的哈希桶中，这就发生了哈希冲突。"
				}
			]
		},
		{
			"ID": "20220826130632-rk997qg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-rk997qg",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "因此，"
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "当有两个以上数量的 kay 被分配到了哈希表中同一个哈希桶上时，此时称这些 key 发生了冲突。"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-tmwc443",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220826130632-tmwc443",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "链式哈希"
				}
			]
		},
		{
			"ID": "20220826130632-1qy0cba",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-1qy0cba",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Redis 采用了「 "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "链式哈希"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 」的方法来解决哈希冲突。"
				}
			]
		},
		{
			"ID": "20220826130632-f1hg76p",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20220826130632-f1hg76p",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20220826130632-1mo8sv8",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20220826130632-1mo8sv8",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "链式哈希是怎么实现的？"
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-ch9c22m",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-ch9c22m",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "实现的方式就是每个哈希表节点都有一个 next 指针，用于指向下一个哈希表节点，因此多个哈希表节点可以用 next 指针构成一个单项链表， "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "被分配到同一个哈希桶上的多个节点可以用这个单项链表连接起来"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " ，这样就解决了哈希冲突。"
				}
			]
		},
		{
			"ID": "20220826130632-m2nto90",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-m2nto90",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "还是用前面的哈希冲突例子，key1 和 key9 经过哈希计算后，都落在同一个哈希桶，链式哈希的话，key1 就会通过 next 指针指向 key9，形成一个单向链表。"
				}
			]
		},
		{
			"ID": "20220826130632-udt53rc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-udt53rc",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E5%BC%8F%E5%93%88%E5%B8%8C.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "不过，链式哈希局限性也很明显，随着链表长度的增加，在查询这一位置上的数据的耗时就会增加，毕竟链表的查询的时间复杂度是 O(n)。"
				}
			]
		},
		{
			"ID": "20220826130632-1v5zsgo",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-1v5zsgo",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "要想解决这一问题，就需要进行 rehash，也就是对哈希表的大小进行扩展。"
				}
			]
		},
		{
			"ID": "20220826130632-r018z61",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-r018z61",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "接下来，看看 Redis 是如何实现的 rehash 的。"
				}
			]
		},
		{
			"ID": "20220826130632-5fask2b",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220826130632-5fask2b",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "rehash"
				}
			]
		},
		{
			"ID": "20220826130632-2eivj44",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-2eivj44",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "哈希表结构设计的这一小节，我给大家介绍了 Redis 使用 dictht 结构体表示哈希表。不过，在实际使用哈希表时，Redis 定义一个 dict 结构体，这个结构体里定义了 "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "两个哈希表（ht[2]）"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 。"
				}
			]
		},
		{
			"ID": "20220826130632-hqhu95d",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220826130632-hqhu95d",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Yw=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "typedef struct dict {\n    …\n    //两个Hash表，交替使用，用于rehash操作\n    dictht ht[2]; \n    …\n} dict;\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220826130632-0m51fx0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-0m51fx0",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "之所以定义了 2 个哈希表，是因为进行 rehash 的时候，需要用上 2 个哈希表了。"
				}
			]
		},
		{
			"ID": "20220826130632-ki1t7d7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-ki1t7d7",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2%E4%B8%AA%E5%93%88%E5%B8%8C%E8%A1%A8.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "在正常服务请求阶段，插入的数据，都会写入到「哈希表 1」，此时的「哈希表 2 」 并没有被分配空间。"
				}
			]
		},
		{
			"ID": "20220826130632-56kdzxk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-56kdzxk",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "随着数据逐步增多，触发了 rehash 操作，这个过程分为三步："
				}
			]
		},
		{
			"ID": "20220826130632-naa11jh",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220826130632-naa11jh",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"ID": "20220826130632-yqrzi57",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-yqrzi57",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-692ph8g",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-692ph8g",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "给「哈希表 2」 分配空间，一般会比「哈希表 1」 大 2 倍；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-w63gr72",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-w63gr72",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-51tastl",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-51tastl",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "将「哈希表 1 」的数据迁移到「哈希表 2」 中；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-kq74s32",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-kq74s32",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-ir3vdj1",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-ir3vdj1",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "迁移完成后，「哈希表 1 」的空间会被释放，并把「哈希表 2」 设置为「哈希表 1」，然后在「哈希表 2」 新创建一个空白的哈希表，为下次 rehash 做准备。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-del7cy4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-del7cy4",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "为了方便你理解，我把 rehash 这三个过程画在了下面这张图："
				}
			]
		},
		{
			"ID": "20220826130632-498g3we",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-498g3we",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/rehash%E8%BF%87%E7%A8%8B.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "这个过程看起来简单，但是其实第二步很有问题， "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "如果「哈希表 1 」的数据量非常大，那么在迁移至「哈希表 2 」的时候，因为会涉及大量的数据拷贝，此时可能会对 Redis 造成阻塞，无法服务其他请求"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 。"
				}
			]
		},
		{
			"ID": "20220826130632-w8juj6z",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220826130632-w8juj6z",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "渐进式 rehash"
				}
			]
		},
		{
			"ID": "20220826130632-17yp54i",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-17yp54i",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "为了避免 rehash 在数据迁移过程中，因拷贝数据的耗时，影响 Redis 性能的情况，所以 Redis 采用了 "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "渐进式 rehash"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " ，也就是将数据的迁移的工作不再是一次性迁移完成，而是分多次迁移。"
				}
			]
		},
		{
			"ID": "20220826130632-47f1lm9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-47f1lm9",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "渐进式 rehash 步骤如下："
				}
			]
		},
		{
			"ID": "20220826130632-e1ufxtf",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220826130632-e1ufxtf",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"ID": "20220826130632-xs58675",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-xs58675",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-jyi605b",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-jyi605b",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "给「哈希表 2」 分配空间；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-qzbv2ft",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-qzbv2ft",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-uzzdans",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-uzzdans",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis 除了会执行对应的操作之外，还会顺序将「哈希表 1 」中索引位置上的所有 key-value 迁移到「哈希表 2」 上"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-qkeshoy",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-qkeshoy",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-8btlmvq",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-8btlmvq",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "随着处理客户端发起的哈希表操作请求数量越多，最终在某个时间嗲呢，会把「哈希表 1 」的所有 key-value 迁移到「哈希表 2」，从而完成 rehash 操作。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-8fe8axs",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-8fe8axs",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这样就巧妙地把一次性大量数据迁移工作的开销，分摊到了多次处理请求的过程中，避免了一次性 rehash 的耗时操作。"
				}
			]
		},
		{
			"ID": "20220826130632-ln93t0m",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-ln93t0m",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在进行渐进式 rehash 的过程中，会有两个哈希表，所以在渐进式 rehash 进行期间，哈希表元素的删除、查找、更新等操作都会在这两个哈希表进行。"
				}
			]
		},
		{
			"ID": "20220826130632-5vam366",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-5vam366",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "比如，查找一个 key 的值的话，先会在「哈希表 1」 里面进行查找，如果没找到，就会继续到哈希表 2 里面进行找到。"
				}
			]
		},
		{
			"ID": "20220826130632-0v75ju9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-0v75ju9",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "另外，在渐进式 rehash 进行期间，新增一个 key-value 时，会被保存到「哈希表 2 」里面，而「哈希表 1」 则不再进行任何添加操作，这样保证了「哈希表 1 」的 key-value 数量只会减少，随着 rehash 操作的完成，最终「哈希表 1 」就会变成空表。"
				}
			]
		},
		{
			"ID": "20220826130632-xd813bw",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220826130632-xd813bw",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "rehash 触发条件"
				}
			]
		},
		{
			"ID": "20220826130632-858lux8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-858lux8",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "介绍了 rehash 那么多，还没说什么时情况下会触发 rehash 操作呢？"
				}
			]
		},
		{
			"ID": "20220826130632-x36urqe",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-x36urqe",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "rehash 的触发条件跟 "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "负载因子（load factor）"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 有关系。"
				}
			]
		},
		{
			"ID": "20220826130632-c2j54no",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-c2j54no",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "负载因子可以通过下面这个公式计算："
				}
			]
		},
		{
			"ID": "20220826130632-l6fsy9p",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-l6fsy9p",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "触发 rehash 操作的条件，主要有两个："
				}
			]
		},
		{
			"ID": "20220826130632-56n8xls",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220826130632-56n8xls",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"ID": "20220826130632-gi82ljm",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-gi82ljm",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-w2lwl7w",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-w2lwl7w",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "当负载因子大于等于 1 ，并且 Redis 没有在执行 bgsave 命令或者 bgrewiteaof 命令，也就是没有执行 RDB 快照或没有进行 AOF 重写的时候，就会进行 rehash 操作。"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-yy5w31s",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-yy5w31s",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-wwl45ve",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-wwl45ve",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "当负载因子大于等于 5 时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会强制进行 rehash 操作。"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-sbzkdnk",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20220826130632-sbzkdnk",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "整数集合"
				}
			]
		},
		{
			"ID": "20220826130632-rz1np8f",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-rz1np8f",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "整数集合是 Set 对象的底层实现之一。当一个 Set 对象只包含整数值元素，并且元素数量不时，就会使用整数集这个数据结构作为底层实现。"
				}
			]
		},
		{
			"ID": "20220826130632-hmf1bio",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220826130632-hmf1bio",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "整数集合结构设计"
				}
			]
		},
		{
			"ID": "20220826130632-o3iw4cw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-o3iw4cw",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "整数集合本质上是一块连续内存空间，它的结构定义如下："
				}
			]
		},
		{
			"ID": "20220826130632-8dyi9zs",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220826130632-8dyi9zs",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Yw=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "typedef struct intset {\n    //编码方式\n    uint32_t encoding;\n    //集合包含的元素数量\n    uint32_t length;\n    //保存元素的数组\n    int8_t contents[];\n} intset;\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220826130632-nidk5fg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-nidk5fg",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "可以看到，保存元素的容器是一个 contents 数组，虽然 contents 被声明为 int8_t 类型的数组，但是实际上 contents 数组并不保存任何 int8_t 类型的元素，contents 数组的真正类型取决于 intset 结构体里的 encoding 属性的值。比如："
				}
			]
		},
		{
			"ID": "20220826130632-8er3udp",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220826130632-8er3udp",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"ID": "20220826130632-q35qrnd",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-q35qrnd",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-monxtni",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-monxtni",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果 encoding 属性值为 INTSET_ENC_INT16，那么 contents 就是一个 int16_t 类型的数组，数组中每一个元素的类型都是 int16_t；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-aveskov",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-aveskov",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-5td1sf5",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-5td1sf5",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果 encoding 属性值为 INTSET_ENC_INT32，那么 contents 就是一个 int32_t 类型的数组，数组中每一个元素的类型都是 int32_t；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-e359gz1",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-e359gz1",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-ikwz704",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-ikwz704",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果 encoding 属性值为 INTSET_ENC_INT64，那么 contents 就是一个 int64_t 类型的数组，数组中每一个元素的类型都是 int64_t；"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-vdtzbub",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-vdtzbub",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "不同类型的 contents 数组，意味着数组的大小也会不同。"
				}
			]
		},
		{
			"ID": "20220826130632-4s6r7na",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220826130632-4s6r7na",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "整数集合的升级操作"
				}
			]
		},
		{
			"ID": "20220826130632-w6tqn53",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-w6tqn53",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "整数集合会有一个升级规则，就是当我们将一个新元素加入到整数集合里面，如果新元素的类型（int32_t）比整数集合现有所有元素的类型（int16_t）都要长时，整数集合需要先进行升级，也就是按新元素的类型（int32_t）扩展 contents 数组的空间大小，然后才能将新元素加入到整数集合里，当然升级的过程中，也要维持整数集合的有序性。"
				}
			]
		},
		{
			"ID": "20220826130632-8gsilgw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-8gsilgw",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "整数集合升级的过程不会重新分配一个新类型的数组，而是在原本的数组上扩展空间，然后在将每个元素按间隔类型大小分割，如果 encoding 属性值为 INTSET_ENC_INT16，则每个元素的间隔就是 16 位。"
				}
			]
		},
		{
			"ID": "20220826130632-q8hqgct",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-q8hqgct",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "举个例子，假设有一个整数集合里有 3 个类型为 int16_t 的元素。"
				}
			]
		},
		{
			"ID": "20220826130632-a37cuob",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-a37cuob",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E5%8D%87%E7%BA%A71.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "现在，往这个整数集合中加入一个新元素 65535，这个新元素需要用 int32_t 类型来保存，所以整数集合要进行升级操作，首先需要为 contents 数组扩容， "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "在原本空间的大小之上再扩容多 80 位（4x32-3x16=80），这样就能保存下 4 个类型为 int32_t 的元素"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 。"
				}
			]
		},
		{
			"ID": "20220826130632-m821ai0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-m821ai0",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E5%8D%87%E7%BA%A72.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "扩容完 contents 数组空间大小后，需要将之前的三个元素转换为 int32_t 类型，并将转换后的元素放置到正确的位上面，并且需要维持底层数组的有序性不变，整个转换过程如下："
				}
			]
		},
		{
			"ID": "20220826130632-4oxcwd6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-4oxcwd6",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E5%8D%87%E7%BA%A73.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "\u003e 整数集合升级有什么好处呢？"
				}
			]
		},
		{
			"ID": "20220826130632-6dceqx5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-6dceqx5",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果要让一个数组同时保存 int16_t、int32_t、int64_t 类型的元素，最简单做法就是直接使用 int64_t 类型的数组。不过这样的话，当如果元素都是 int16_t 类型的，就会造成内存浪费的情况。"
				}
			]
		},
		{
			"ID": "20220826130632-os5woqv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-os5woqv",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "整数集合升级就能避免这种情况，如果一直向整数集合添加 int16_t 类型的元素，那么整数集合的底层实现就一直是用 int16_t 类型的数组，只有在我们要将 int32_t 类型或 int64_t 类型的元素添加到集合时，才会对数组进行升级操作。"
				}
			]
		},
		{
			"ID": "20220826130632-k3e0kix",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-k3e0kix",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "因此，整数集合升级的好处是 "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "节省内存资源"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 。"
				}
			]
		},
		{
			"ID": "20220826130632-d54pavc",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20220826130632-d54pavc",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20220826130632-y26qd1a",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20220826130632-y26qd1a",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "整数集合支持降级操作吗？"
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-rk9k87a",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-rk9k87a",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "不支持降级操作"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " ，一旦对数组进行了升级，就会一直保持升级后的状态。比如前面的升级操作的例子，如果删除了 65535 元素，整数集合的数组还是 int32_t 类型的，并不会因此降级为 int16_t 类型。"
				}
			]
		},
		{
			"ID": "20220826130632-z1zc5eo",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20220826130632-z1zc5eo",
				"updated": "20220826130632"
			}
		},
		{
			"ID": "20220826130632-55ecyjl",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20220826130632-55ecyjl",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "跳表"
				}
			]
		},
		{
			"ID": "20220826130632-abnap7c",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-abnap7c",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Redis 只有在 Zset 对象的底层实现用到了跳表，跳表的优势是能支持平均 O(logN) 复杂度的节点查找。"
				}
			]
		},
		{
			"ID": "20220826130632-lnndy46",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-lnndy46",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Zset 对象是唯一一个同时使用了两个数据结构来实现的 Redis 对象，这两个数据结构一个是跳表，一个是哈希表。这样的好处是既能进行高效的范围查询，也能进行高效单点查询。"
				}
			]
		},
		{
			"ID": "20220826130632-l9dqa60",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220826130632-l9dqa60",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Yw=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "typedef struct zset {\n    dict *dict;\n    zskiplist *zsl;\n} zset;\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220826130632-mr363yq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-mr363yq",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Zset 对象能支持范围查询（如 ZRANGEBYSCORE 操作），这是因为它的数据结构设计采用了跳表，而又能以常数复杂度获取元素权重（如 ZSCORE 操作），这是因为它同时采用了哈希表进行索引。"
				}
			]
		},
		{
			"ID": "20220826130632-7qr5bdb",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-7qr5bdb",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "接下来，详细的说下跳表。"
				}
			]
		},
		{
			"ID": "20220826130632-0lj3n8m",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220826130632-0lj3n8m",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "跳表结构设计"
				}
			]
		},
		{
			"ID": "20220826130632-ayi6ksr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-ayi6ksr",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "链表在查找元素的时候，因为需要逐一查找，所以查询效率非常低，时间复杂度是O(N)，于是就出现了跳表。 "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " ，这样的好处是能快读定位数据。"
				}
			]
		},
		{
			"ID": "20220826130632-wvv2g3h",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-wvv2g3h",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "那跳表长什么样呢？我这里举个例子，下图展示了一个层级为 3 的跳表。"
				}
			]
		},
		{
			"ID": "20220826130632-c0y6zro",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-c0y6zro",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3%E5%B1%82%E8%B7%B3%E8%A1%A8.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "图中头节点有 L0~L2 三个头指针，分别指向了不同层级的节点，然后每个层级的节点都通过指针连接起来："
				}
			]
		},
		{
			"ID": "20220826130632-bxvmd4a",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220826130632-bxvmd4a",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"ID": "20220826130632-jm1o5c5",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-jm1o5c5",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-l4nkdup",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-l4nkdup",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "L0 层级共有 5 个节点，分别是节点1、2、3、4、5；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-vjg7chq",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-vjg7chq",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-7qni1lk",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-7qni1lk",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "L1 层级共有 3 个节点，分别是节点 2、3、5；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-9uf5ugm",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-9uf5ugm",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-kg0uocb",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-kg0uocb",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "L2 层级只有 1 个节点，也就是节点 3 。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-nv46ntw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-nv46ntw",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果我们要在链表中查找节点 4 这个元素，只能从头开始遍历链表，需要查找 4 次，而使用了跳表后，只需要查找 2 次就能定位到节点 4，因为可以在头节点直接从 L2 层级跳到节点 3，然后再往前遍历找到节点 4。"
				}
			]
		},
		{
			"ID": "20220826130632-u1n5b5y",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-u1n5b5y",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "可以看到，这个查找过程就是在多个层级上跳来跳去，最后定位到元素。当数据量很大时，跳表的查找复杂度就是 O(logN)。"
				}
			]
		},
		{
			"ID": "20220826130632-1xbb7j3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-1xbb7j3",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "那跳表节点是怎么实现多层级的呢？这就需要看「跳表节点」的数据结构了，如下："
				}
			]
		},
		{
			"ID": "20220826130632-nmt1xwd",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220826130632-nmt1xwd",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Yw=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "typedef struct zskiplistNode {\n    //Zset 对象的元素值\n    sds ele;\n    //元素权重值\n    double score;\n    //后向指针\n    struct zskiplistNode *backward;\n\n    //节点的level数组，保存每层上的前向指针和跨度\n    struct zskiplistLevel {\n        struct zskiplistNode *forward;\n        unsigned long span;\n    } level[];\n} zskiplistNode;\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220826130632-mdvwdcy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-mdvwdcy",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Zset 对象要同时保存元素和元素的权重，对应到跳表节点结构里就是 sds 类型的 ele 变量和 double 类型的 score 变量。每个跳表节点都有一个后向指针，指向前一个节点，目的是为了方便从跳表的尾节点开始访问节点，这样倒序查找时很方便。"
				}
			]
		},
		{
			"ID": "20220826130632-sefv6cw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-sefv6cw",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "跳表是一个带有层级关系的链表，而且每一层级可以包含多个节点，每一个节点通过指针连接起来，实现这一特性就是靠跳表节点结构体中的 "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "zskiplistLevel 结构体类型的 level 数组"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 。"
				}
			]
		},
		{
			"ID": "20220826130632-6pzfmvg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-6pzfmvg",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "level 数组中的每一个元素代表跳表的一层，也就是由 zskiplistLevel 结构体表示，比如 leve[0] 就表示第一层，leve[1] 就表示第二层。zskiplistLevel 结构体里定义了「指向下一个跳表节点的指针」和「跨度」，跨度时用来记录两个节点之间的距离。"
				}
			]
		},
		{
			"ID": "20220826130632-mn0tf6a",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-mn0tf6a",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "比如，下面这张图，展示了各个节点的跨度。"
				}
			]
		},
		{
			"ID": "20220826130632-8v8c272",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-8v8c272",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3%E5%B1%82%E8%B7%B3%E8%A1%A8-%E8%B7%A8%E5%BA%A6.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "第一眼看到跨度的时候，以为是遍历操作有关，实际上并没有任何关系，遍历操作只需要用前向指针就可以完成了。"
				}
			]
		},
		{
			"ID": "20220826130632-7be07lw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-7be07lw",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "跨度实际上是为了计算这个节点在跳表中的排位"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 。具体怎么做的呢？因为跳表中的节点都是按序排列的，那么计算某个节点排位的时候，从头节点点到该结点的查询路径上，将沿途访问过的所有层的跨度累加起来，得到的结果就是目标节点在跳表中的排位。"
				}
			]
		},
		{
			"ID": "20220826130632-jk7crln",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-jk7crln",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "举个例子，查找图中节点 3 在跳表中的排位，从头节点开始查找节点 3，查找的过程只经过了一个层（L3），并且层的跨度是 3，所以节点 3 在跳表中的排位是 3。"
				}
			]
		},
		{
			"ID": "20220826130632-z75tl5h",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-z75tl5h",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "另外，图中的头节点其实也是 zskiplistNode 跳表节点，只不过头节点的后向指针、权重、元素值都会被用到，所以图中省略了这部分。"
				}
			]
		},
		{
			"ID": "20220826130632-c8ligic",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-c8ligic",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "问题来了，由谁定义哪个跳表节点是头节点呢？这就介绍「跳表」结构体了，如下所示："
				}
			]
		},
		{
			"ID": "20220826130632-2g6xbg0",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220826130632-2g6xbg0",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Yw=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "typedef struct zskiplist {\n    struct zskiplistNode *header, *tail;\n    unsigned long length;\n    int level;\n} zskiplist;\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220826130632-pjqnj3e",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-pjqnj3e",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "跳表结构里包含了："
				}
			]
		},
		{
			"ID": "20220826130632-ls5ypmh",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220826130632-ls5ypmh",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"ID": "20220826130632-92llxp1",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-92llxp1",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-e67ehd6",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-e67ehd6",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "跳表的头尾节点，便于在O(1)时间复杂度内访问跳表的头节点和尾节点；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-kfl1nx4",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-kfl1nx4",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-l774xmq",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-l774xmq",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "跳表的长度，便于在O(1)时间复杂度获取跳表节点的数量；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-9v73gos",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-9v73gos",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-ey2p0k2",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-ey2p0k2",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "跳表的最大层数，便于在O(1)时间复杂度获取跳表中层高最大的那个节点的层数量；"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-cckr7w8",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220826130632-cckr7w8",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "跳表节点查询过程"
				}
			]
		},
		{
			"ID": "20220826130632-wuz4qs6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-wuz4qs6",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "查找一个跳表节点的过程时，跳表会从头节点的最高层开始，逐一遍历每一层。在遍历某一层的跳表节点时，会用跳表节点中的 SDS 类型的元素和元素的权重来进行判断，共有两个判断条件："
				}
			]
		},
		{
			"ID": "20220826130632-lph9878",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220826130632-lph9878",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"ID": "20220826130632-lujdygp",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-lujdygp",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-pmbdoeq",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-pmbdoeq",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果当前节点的权重「小于」要查找的权重时，跳表就会访问该层上的下一个节点。"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-7m8d3ge",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-7m8d3ge",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-8s09g49",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-8s09g49",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果当前节点的权重「等于」要查找的权重时，并且当前节点的 SDS 类型数据「小于」要查找的数据时，跳表就会访问该层上的下一个节点。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-8hmacaw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-8hmacaw",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果上面两个条件都不满足，或者下一个节点为空时，跳表就会使用目前遍历到的节点的 level 数组里的下一层指针，然后沿着下一层指针继续查找，这就相当于跳到了下一层接着查找。"
				}
			]
		},
		{
			"ID": "20220826130632-55xwps3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-55xwps3",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "举个例子，下图有个 3 层级的跳表。"
				}
			]
		},
		{
			"ID": "20220826130632-4xr0xqw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-4xr0xqw",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%A1%A8%E6%9F%A5%E8%AF%A2.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "如果要查找「元素：abcd，权重：4」的节点，查找的过程是这样的："
				}
			]
		},
		{
			"ID": "20220826130632-x06isz5",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220826130632-x06isz5",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"ID": "20220826130632-arf1vle",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-arf1vle",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-kf6tusf",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-kf6tusf",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "先从头节点的最高层开始，L2 指向了「元素：abc，权重：3」节点，这个节点的权重比要查找节点的小，所以要访问该层上的下一个节点；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-zir246r",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-zir246r",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-wctjt5o",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-wctjt5o",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "但是该层上的下一个节点是空节点，于是就会跳到「元素：abc，权重：3」节点的下一层去找，也就是 leve[1];"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-uj3fwx0",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-uj3fwx0",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-w53zkn8",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-w53zkn8",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "「元素：abc，权重：3」节点的 leve[1] 的下一个指针指向了「元素：abcde，权重：4」的节点，然后将其和要查找的节点比较。虽然「元素：abcde，权重：4」的节点的权重和要查找的权重相同，但是当前节点的 SDS 类型数据「大于」要查找的数据，所以会继续跳到「元素：abc，权重：3」节点的下一层去找，也就是 leve[0]；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-kj0hecy",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-kj0hecy",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-6tvg3ce",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-6tvg3ce",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "「元素：abc，权重：3」节点的 leve[0] 的下一个指针指向了「元素：abcd，权重：4」的节点，该节点正是要查找的节点，查询结束。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-a4m55ig",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220826130632-a4m55ig",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "跳表节点层数设置"
				}
			]
		},
		{
			"ID": "20220826130632-l82dy46",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-l82dy46",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "跳表的相邻两层的节点数量的比例会影响跳表的查询性能。"
				}
			]
		},
		{
			"ID": "20220826130632-1jezxp5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-1jezxp5",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "举个例子，下图的跳表，第二层的节点数量只有 1 个，而第一层的节点数量有 6 个。"
				}
			]
		},
		{
			"ID": "20220826130632-b8nnaiv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-b8nnaiv",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%A1%A8on.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "这时，如果想要查询节点 6，那基本就跟链表的查询复杂度一样，就需要在第一层的节点中依次顺序查找，复杂度就是 O(N) 了。所以，为了降低查询复杂度，我们就需要维持相邻层结点数间的关系。"
				}
			]
		},
		{
			"ID": "20220826130632-pjoovmi",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-pjoovmi",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "跳表的相邻两层的节点数量最理想的比例是 2:1，查找复杂度可以降低到 O(logN)"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 。"
				}
			]
		},
		{
			"ID": "20220826130632-7kmpdxm",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-7kmpdxm",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "下图的跳表就是，相邻两层的节点数量的比例是 2 : 1。"
				}
			]
		},
		{
			"ID": "20220826130632-ksur03x",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-ksur03x",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%A1%A82%E6%AF%941.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "\u003e 那怎样才能维持相邻两层的节点数量的比例为 2 : 1 呢？"
				}
			]
		},
		{
			"ID": "20220826130632-k7er3g0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-k7er3g0",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果采用新增节点或者删除节点时，来调整跳表节点以维持比例的方法的话，会带来额外的开销。"
				}
			]
		},
		{
			"ID": "20220826130632-tsxmeka",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-tsxmeka",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Redis 则采用一种巧妙的方法是， "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "跳表在创建节点的时候，随机生成每个节点的层数"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " ，并没有严格维持相邻两层的节点数量比例为 2 : 1 的情况。"
				}
			]
		},
		{
			"ID": "20220826130632-fpbymmx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-fpbymmx",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "具体的做法是， "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 。"
				}
			]
		},
		{
			"ID": "20220826130632-06by1y5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-06by1y5",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这样的做法，相当于每增加一层的概率不超过 25%，层数越高，概率越低，层高最大限制是 64。"
				}
			]
		},
		{
			"ID": "20220826130632-woqa73v",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20220826130632-woqa73v",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "quicklist"
				}
			]
		},
		{
			"ID": "20220826130632-dx3al7t",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-dx3al7t",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在 Redis 3.0 之前，List 对象的底层数据结构是双向链表或者压缩列表。然后在 Redis 3.2 的时候，List 对象的底层改由 quicklist 数据结构实现。"
				}
			]
		},
		{
			"ID": "20220826130632-kn37lyo",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-kn37lyo",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "其实 quicklist 就是「双向链表 + 压缩列表」组合，因为一个 quicklist 就是一个链表，而链表中的每个元素又是一个压缩列表。"
				}
			]
		},
		{
			"ID": "20220826130632-d9s62sw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-d9s62sw",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在前面讲压缩列表的时候，我也提到了压缩列表的不足，虽然压缩列表是通过紧凑型的内存布局节省了内存开销，但是因为它的结构设计，如果保存的元素数量增加，或者元素变大了，压缩列表会有「连锁更新」的风险，一旦发生，会造成性能下降。"
				}
			]
		},
		{
			"ID": "20220826130632-j63xm5j",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-j63xm5j",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "quicklist 解决办法，"
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能。"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-c2huyim",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220826130632-c2huyim",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "quicklist 结构设计"
				}
			]
		},
		{
			"ID": "20220826130632-qdmbwt0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-qdmbwt0",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "quicklist 的结构体跟链表的结构体类似，都包含了表头和表尾，区别在于 quicklist 的节点是 quicklistNode。"
				}
			]
		},
		{
			"ID": "20220826130632-le6i0kq",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220826130632-le6i0kq",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Yw=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "typedef struct quicklist {\n    //quicklist的链表头\n    quicklistNode *head;      //quicklist的链表头\n    //quicklist的链表头\n    quicklistNode *tail; \n    //所有压缩列表中的总元素个数\n    unsigned long count;\n    //quicklistNodes的个数\n    unsigned long len;       \n    ...\n} quicklist;\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220826130632-laf13wf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-laf13wf",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "接下来看看，quicklistNode 的结构定义："
				}
			]
		},
		{
			"ID": "20220826130632-7p6naa9",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220826130632-7p6naa9",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Yw=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "typedef struct quicklistNode {\n    //前一个quicklistNode\n    struct quicklistNode *prev;     //前一个quicklistNode\n    //下一个quicklistNode\n    struct quicklistNode *next;     //后一个quicklistNode\n    //quicklistNode指向的压缩列表\n    unsigned char *zl;              \n    //压缩列表的的字节大小\n    unsigned int sz;                \n    //压缩列表的元素个数\n    unsigned int count : 16;        //ziplist中的元素个数 \n    ....\n} quicklistNode;\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220826130632-ttl8pij",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-ttl8pij",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "可以看到，quicklistNode 结构体里包含了前一个节点和下一个节点指针，这样每个 quicklistNode 形成了一个双向链表。但是链表节点的元素不再是单纯保存元素值，而是保存了一个压缩列表，所以 quicklistNode 结构体里有个指向压缩列表的指针 *zl。"
				}
			]
		},
		{
			"ID": "20220826130632-22qikyw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-22qikyw",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我画了一张图，方便你理解 quicklist 数据结构。"
				}
			]
		},
		{
			"ID": "20220826130632-797r595",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-797r595",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/quicklist.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "在向 quicklist 添加一个元素的时候，不会像普通的链表那样，直接新建一个链表节点。而是会检查插入位置的压缩列表是否能容纳该元素，如果能容纳就直接保存到 quicklistNode 结构里的压缩列表，如果不能容纳，才会新建一个新的 quicklistNode 结构。"
				}
			]
		},
		{
			"ID": "20220826130632-oe5a9u1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-oe5a9u1",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "quicklist 会控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来规避潜在的连锁更新的风险，但是这并没有完全解决连锁更新的问题。"
				}
			]
		},
		{
			"ID": "20220826130632-04gfvm5",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20220826130632-04gfvm5",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "listpack"
				}
			]
		},
		{
			"ID": "20220826130632-wi1r976",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-wi1r976",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "quicklist 虽然通过控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来减少连锁更新带来的性能影响，但是并没有完全解决连锁更新的问题。"
				}
			]
		},
		{
			"ID": "20220826130632-8rcxrfi",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-8rcxrfi",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "因为 quicklistNode 还是用了压缩列表来保存元素，压缩列表连锁更新的问题，来源于它的结构设计，所以要想彻底解决这个问题，需要设计一个新的数据结构。"
				}
			]
		},
		{
			"ID": "20220826130632-46v525f",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-46v525f",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "于是，Redis 在 5.0 新设计一个数据结构叫 listpack，目的是替代压缩列表，它最大特点是 listpack 中每个节点不再包含前一个节点的长度了，压缩列表每个节点正因为需要保存前一个节点的长度字段，就会有连锁更新的隐患。"
				}
			]
		},
		{
			"ID": "20220826130632-8umkbb5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-8umkbb5",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "我看了 Redis 的 Github，在最新 6.2 发行版本中，Redis Hash 对象、Set 对象的底层数据结构的压缩列表还未被替换成 listpack，而 Redis 的最新代码（还未发布版本）已经将所有用到压缩列表底层数据结构的 Redis 对象替换成 listpack 数据结构来实现，估计不久将来，Redis 就会发布一个将压缩列表为 listpack 的发行版本"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 。"
				}
			]
		},
		{
			"ID": "20220826130632-f8ncfk2",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220826130632-f8ncfk2",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "listpack 结构设计"
				}
			]
		},
		{
			"ID": "20220826130632-5z75unu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-5z75unu",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "listpack 采用了压缩列表的很多优秀的设计，比如还是用一块连续的内存空间来紧凑地保存数据，并且为了节省内存的开销，listpack 节点会采用不同的编码方式保存不同大小的数据。"
				}
			]
		},
		{
			"ID": "20220826130632-ddd4wny",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-ddd4wny",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们先看看 listpack 结构："
				}
			]
		},
		{
			"ID": "20220826130632-7fu4tmg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-7fu4tmg",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/listpack.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "listpack 头包含两个属性，分别记录了 listpack 总字节数和元素数量，然后 listpack 末尾也有个结尾标识。图中的 listpack entry 就是 listpack 的节点了。"
				}
			]
		},
		{
			"ID": "20220826130632-glnl4u4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-glnl4u4",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "每个 listpack 节点结构如下："
				}
			]
		},
		{
			"ID": "20220826130632-v10pgj8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-v10pgj8",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/listpack%E8%8A%82%E7%82%B9.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "主要包含三个方面内容："
				}
			]
		},
		{
			"ID": "20220826130632-gijrh90",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220826130632-gijrh90",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"ID": "20220826130632-ntae5yn",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-ntae5yn",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-61412sh",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-61412sh",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "encoding，定义该元素的编码类型，会对不同长度的整数和字符串进行编码；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-vmr6sl2",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-vmr6sl2",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-i9z7ja4",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-i9z7ja4",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "data，实际存放的数据；"
								}
							]
						}
					]
				},
				{
					"ID": "20220826130632-vp5tt59",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220826130632-vp5tt59",
						"updated": "20220826130632"
					},
					"Children": [
						{
							"ID": "20220826130632-9ul35n8",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220826130632-9ul35n8",
								"updated": "20220826130632"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "len，encoding+data的总长度；"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220826130632-baxxcz1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826130632-baxxcz1",
				"updated": "20220826130632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "可以看到， "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "listpack 没有压缩列表中记录前一个节点长度的字段了，listpack 只记录当前节点的长度，当我们向 listpack 加入一个新元素的时候，不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 。"
				}
			]
		},
		{
			"ID": "20220826131151-g5zlnfe",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220826131151-g5zlnfe"
			}
		}
	]
}